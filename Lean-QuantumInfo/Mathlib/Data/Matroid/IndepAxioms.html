<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Data.Matroid.IndepAxioms</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Data.Matroid.IndepAxioms";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Data</span>.<span class="name">Matroid</span>.<span class="name">IndepAxioms</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Data/Matroid/Basic.html">Mathlib.Data.Matroid.Basic</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Data.Matroid.IndepAxioms" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#IndepMatroid"><span class="name">IndepMatroid</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.matroid"><span class="name">IndepMatroid</span>.<span class="name">matroid</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.matroid_E"><span class="name">IndepMatroid</span>.<span class="name">matroid_E</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.matroid_Indep"><span class="name">IndepMatroid</span>.<span class="name">matroid_Indep</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.matroid_Base"><span class="name">IndepMatroid</span>.<span class="name">matroid_Base</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.matroid_indep_iff"><span class="name">IndepMatroid</span>.<span class="name">matroid_indep_iff</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofFinitary"><span class="name">IndepMatroid</span>.<span class="name">ofFinitary</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofFinitary_E"><span class="name">IndepMatroid</span>.<span class="name">ofFinitary_E</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofFinitary_indep"><span class="name">IndepMatroid</span>.<span class="name">ofFinitary_indep</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofFinitary_finitary"><span class="name">IndepMatroid</span>.<span class="name">ofFinitary_finitary</span></a></div><div class="nav_link"><a class="break_within" href="#Matroid.existsMaximalSubsetProperty_of_bdd"><span class="name">Matroid</span>.<span class="name">existsMaximalSubsetProperty_of_bdd</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofBdd"><span class="name">IndepMatroid</span>.<span class="name">ofBdd</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofBdd_E"><span class="name">IndepMatroid</span>.<span class="name">ofBdd_E</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofBdd_indep"><span class="name">IndepMatroid</span>.<span class="name">ofBdd_indep</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.instFiniteRkMatroidOfBdd"><span class="name">IndepMatroid</span>.<span class="name">instFiniteRkMatroidOfBdd</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofBddAugment"><span class="name">IndepMatroid</span>.<span class="name">ofBddAugment</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofBddAugment_E"><span class="name">IndepMatroid</span>.<span class="name">ofBddAugment_E</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofBddAugment_indep"><span class="name">IndepMatroid</span>.<span class="name">ofBddAugment_indep</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofBddAugment_finiteRk"><span class="name">IndepMatroid</span>.<span class="name">ofBddAugment_finiteRk</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofFinite"><span class="name">IndepMatroid</span>.<span class="name">ofFinite</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofFinite_E"><span class="name">IndepMatroid</span>.<span class="name">ofFinite_E</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofFinite_indep"><span class="name">IndepMatroid</span>.<span class="name">ofFinite_indep</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofFinite_finite"><span class="name">IndepMatroid</span>.<span class="name">ofFinite_finite</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofFinset"><span class="name">IndepMatroid</span>.<span class="name">ofFinset</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofFinset_E"><span class="name">IndepMatroid</span>.<span class="name">ofFinset_E</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofFinset_indep"><span class="name">IndepMatroid</span>.<span class="name">ofFinset_indep</span></a></div><div class="nav_link"><a class="break_within" href="#IndepMatroid.ofFinset_indep'"><span class="name">IndepMatroid</span>.<span class="name">ofFinset_indep'</span></a></div><div class="nav_link"><a class="break_within" href="#Matroid.ofExistsMatroid"><span class="name">Matroid</span>.<span class="name">ofExistsMatroid</span></a></div><div class="nav_link"><a class="break_within" href="#Matroid.ofExistsMatroid_E"><span class="name">Matroid</span>.<span class="name">ofExistsMatroid_E</span></a></div><div class="nav_link"><a class="break_within" href="#Matroid.ofBase"><span class="name">Matroid</span>.<span class="name">ofBase</span></a></div><div class="nav_link"><a class="break_within" href="#Matroid.ofBase_E"><span class="name">Matroid</span>.<span class="name">ofBase_E</span></a></div><div class="nav_link"><a class="break_within" href="#Matroid.ofExistsFiniteBase"><span class="name">Matroid</span>.<span class="name">ofExistsFiniteBase</span></a></div><div class="nav_link"><a class="break_within" href="#Matroid.ofExistsFiniteBase_E"><span class="name">Matroid</span>.<span class="name">ofExistsFiniteBase_E</span></a></div><div class="nav_link"><a class="break_within" href="#Matroid.ofExistsFiniteBase_base"><span class="name">Matroid</span>.<span class="name">ofExistsFiniteBase_base</span></a></div><div class="nav_link"><a class="break_within" href="#Matroid.ofExistsFiniteBase_finiteRk"><span class="name">Matroid</span>.<span class="name">ofExistsFiniteBase_finiteRk</span></a></div><div class="nav_link"><a class="break_within" href="#Matroid.ofBaseOfFinite"><span class="name">Matroid</span>.<span class="name">ofBaseOfFinite</span></a></div><div class="nav_link"><a class="break_within" href="#Matroid.ofBaseOfFinite_E"><span class="name">Matroid</span>.<span class="name">ofBaseOfFinite_E</span></a></div><div class="nav_link"><a class="break_within" href="#Matroid.ofBaseOfFinite_base"><span class="name">Matroid</span>.<span class="name">ofBaseOfFinite_base</span></a></div><div class="nav_link"><a class="break_within" href="#Matroid.ofBaseOfFinite_finite"><span class="name">Matroid</span>.<span class="name">ofBaseOfFinite_finite</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Matroid-Independence-and-Basis-axioms">Matroid Independence and Basis axioms <a class="hover-link" href="#Matroid-Independence-and-Basis-axioms">#</a></h1><p>Matroids in mathlib are defined axiomatically in terms of bases,
but can be described just as naturally via their collections of independent sets,
and in fact such a description, being more 'verbose', can often be useful.
As well as this, the definition of a <code><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a></code> uses an unwieldy 'maximality'
axiom that can be dropped in cases where there is some finiteness assumption.</p><p>This file provides several ways to do define a matroid in terms of its independence or base
predicates, using axiom sets that are appropriate in different settings,
and often much simpler than the general definition.
It also contains <code>simp</code> lemmas and typeclasses as appropriate.</p><p>All the independence axiom sets need nontriviality (the empty set is independent),
monotonicity (subsets of independent sets are independent),
and some form of 'augmentation' axiom, which allows one to enlarge a non-maximal independent set.
This augmentation axiom is still required when there are finiteness assumptions, but is simpler.
It just states that if <code>I</code> is a finite independent set and <code>J</code> is a larger finite
independent set, then there exists <code>e ∈ J \ I</code> for which <code>insert e I</code> is independent.
This is the axiom that appears in most of the definitions.</p><h2 class="markdown-heading" id="Implementation-Details">Implementation Details <a class="hover-link" href="#Implementation-Details">#</a></h2><p>To facilitate building a matroid from its independent sets, we define a structure <code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a></code>
which has a ground set <code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.E">E</a></code>, an independence predicate <code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.Indep">Indep</a></code>, and some axioms as its fields.
This structure is another encoding of the data in a <code><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a></code>; the function <code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.matroid">IndepMatroid.matroid</a></code>
constructs a <code><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a></code> from an <code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a></code>.</p><p>This is convenient because if one wants to define <code>M : <a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a> α</code> from a known independence
predicate <code>Ind</code>, it is easier to define an <code>M' : <a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a> α</code> so that <code>M'.<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.Indep">Indep</a> = Ind</code> and
then set <code>M = M'.<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.matroid">matroid</a></code> than it is to directly define <code>M</code> with the base axioms.
The simp lemma <code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.matroid_indep_iff">IndepMatroid.matroid_indep_iff</a></code> is important here; it shows that <code>M.<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.Indep">Indep</a> = Ind</code>,
so the <code><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a></code> constructed is the right one, and the intermediate <code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a></code> can be
made essentially invisible by the simplifier when working with <code>M</code>.</p><p>Because of this setup, we don't define any API for <code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a></code>, as it would be
a redundant copy of the existing API for <code><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid.Indep">Matroid.Indep</a></code>.
(In particular, one could define a natural equivalence <code>e : <a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a> α ≃ <a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a> α</code>
with <code>e.toFun = <a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.matroid">IndepMatroid.matroid</a></code>, but this would be pointless, as there is no need
for the inverse of <code>e</code>).</p><h2 class="markdown-heading" id="Main-definitions">Main definitions <a class="hover-link" href="#Main-definitions">#</a></h2><ul>
<li><p><code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a> α</code> is a matroid structure on <code>α</code> described in terms of its independent sets
in full generality, using infinite versions of the axioms.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.matroid">IndepMatroid.matroid</a></code> turns <code>M' : <a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a> α</code> into <code>M : <a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a> α</code> with <code>M'.<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.Indep">Indep</a> = M.<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.Indep">Indep</a></code>.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinitary">IndepMatroid.ofFinitary</a></code> constructs an <code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a></code> whose associated <code><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a></code> is <code>Finitary</code>
in the special case where independence of a set is determined only by that of its
finite subsets. This construction uses Zorn's lemma.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBdd">IndepMatroid.ofBdd</a></code> constructs an <code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a></code> in the case where there is some known
absolute upper bound on the size of an independent set. This uses the infinite version of
the augmentation axiom; the corresponding <code><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a></code> is <code>FiniteRk</code>.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBddAugment">IndepMatroid.ofBddAugment</a></code> is the same as the above, but with a finite augmentation axiom.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinite">IndepMatroid.ofFinite</a></code> constructs an <code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a></code> from a finite ground set in terms of
its independent sets.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinset">IndepMatroid.ofFinset</a></code> constructs an <code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a> α</code> whose corresponding matroid is <code>Finitary</code>
from an independence predicate on <code><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> α</code>.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofExistsMatroid">Matroid.ofExistsMatroid</a></code> constructs a 'copy' of a matroid that is known only
existentially, but whose independence predicate is known explicitly.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofExistsFiniteBase">Matroid.ofExistsFiniteBase</a></code> constructs a matroid from its bases, if it is known that one
of them is finite. This gives a <code>FiniteRk</code> matroid.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofBaseOfFinite">Matroid.ofBaseOfFinite</a></code> constructs a <code><a href="../../.././Mathlib/Data/Finite/Defs.html#Finite">Finite</a></code> matroid from its bases.</p>
</li>
</ul></div><div class="decl" id="IndepMatroid"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L89-L103">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid"><span class="name">IndepMatroid</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u_2</div></div><p>A matroid as defined by the independence axioms. This is the same thing as a <code><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a></code>,
and so does not need its own API; it exists to make it easier to construct a matroid from its
independent sets. The constructed <code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a></code> can then be converted into a matroid
with <code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.matroid">IndepMatroid.matroid</a></code>.</p><ul class="structure_fields" id="IndepMatroid.mk"><li id="IndepMatroid.E" class="structure_field"><div class="structure_field_info">E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span></div><div class="structure_field_doc"><p>The ground set</p></div></li><li id="IndepMatroid.Indep" class="structure_field"><div class="structure_field_info">Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span></div><div class="structure_field_doc"><p>The independence predicate</p></div></li><li id="IndepMatroid.indep_empty" class="structure_field"><div class="structure_field_info">indep_empty : <span class="fn"><span class="fn"><span class="fn">self</span>.Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span></div></li><li id="IndepMatroid.indep_subset" class="structure_field"><div class="structure_field_info">indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">self</span>.Indep</span> <span class="fn">I</span></span></span></span></span></div></li><li id="IndepMatroid.indep_aug" class="structure_field"><div class="structure_field_info">indep_aug : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#Maximal">Maximal</a> <span class="fn"><span class="fn">self</span>.Indep</span> <span class="fn">I</span></span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#Maximal">Maximal</a> <span class="fn"><span class="fn">self</span>.Indep</span> <span class="fn">B</span></span> → <span class="fn">∃ <span class="fn">x</span> ∈ <span class="fn"><span class="fn">B</span> <a href="../../.././Init/Core.html#SDiff.sdiff">\</a> <span class="fn">I</span></span>, <span class="fn"><span class="fn"><span class="fn">self</span>.Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">x</span> <span class="fn">I</span>)</span></span></span></span></span></span></span></div></li><li id="IndepMatroid.indep_maximal" class="structure_field"><div class="structure_field_info">indep_maximal : <span class="fn">∀ <span class="fn">X</span> ⊆ <span class="fn"><span class="fn">self</span>.E</span>, <span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid.ExistsMaximalSubsetProperty">Matroid.ExistsMaximalSubsetProperty</a> <span class="fn"><span class="fn">self</span>.Indep</span> <span class="fn">X</span></span></span></div></li><li id="IndepMatroid.subset_ground" class="structure_field"><div class="structure_field_info">subset_ground : <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn"><span class="fn">self</span>.E</span></span></span></span></div></li></ul><details id="instances-for-list-IndepMatroid" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="IndepMatroid.matroid"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L107-L133">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.matroid"><span class="name">IndepMatroid</span>.<span class="name">matroid</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(M : <span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a> <span class="fn">α</span></span></div></div><p>An <code>M : <a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a> α</code> gives a <code><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a> α</code> whose bases are the maximal <code>M</code>-independent sets.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">M</span>.matroid</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">E</span> := <span class="fn"><span class="fn">M</span>.E</span>, <span class="fn">Base</span> := <span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#Maximal">Maximal</a> <span class="fn"><span class="fn">M</span>.Indep</span></span>, <span class="fn">Indep</span> := <span class="fn"><span class="fn">M</span>.Indep</span>, <span class="fn">indep_iff'</span> := <span class="fn">⋯</span>, <span class="fn">exists_base</span> := <span class="fn">⋯</span>, <span class="fn">base_exchange</span> := <span class="fn">⋯</span>,
    <span class="fn">maximality</span> := <span class="fn">⋯</span>, <span class="fn">subset_ground</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-IndepMatroid.matroid" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="IndepMatroid.matroid_E"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L108-L108">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.matroid_E"><span class="name">IndepMatroid</span>.<span class="name">matroid_E</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(M : <span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">M</span>.matroid</span>.E</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">M</span>.E</span></span></div></div></div></div><div class="decl" id="IndepMatroid.matroid_Indep"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L108-L108">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.matroid_Indep"><span class="name">IndepMatroid</span>.<span class="name">matroid_Indep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(M : <span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a✝ : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">M</span>.matroid</span>.Indep</span> <span class="fn">a✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">M</span>.Indep</span> <span class="fn">a✝</span></span></span></div></div></div></div><div class="decl" id="IndepMatroid.matroid_Base"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L108-L108">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.matroid_Base"><span class="name">IndepMatroid</span>.<span class="name">matroid_Base</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(M : <span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">M</span>.matroid</span>.Base</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#Maximal">Maximal</a> <span class="fn"><span class="fn">M</span>.Indep</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="IndepMatroid.matroid_indep_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L135-L136">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.matroid_indep_iff"><span class="name">IndepMatroid</span>.<span class="name">matroid_indep_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{M : <span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">M</span>.matroid</span>.Indep</span> <span class="fn">I</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">M</span>.Indep</span> <span class="fn">I</span></span></span></div></div></div></div><div class="decl" id="IndepMatroid.ofFinitary"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L138-L233">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinitary"><span class="name">IndepMatroid</span>.<span class="name">ofFinitary</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug :
  <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span>.Finite</span> → <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">J</span>.Finite</span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">I</span>.ncard</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">J</span>.ncard</span></span> → <span class="fn">∃ <span class="fn">e</span> ∈ <span class="fn">J</span>, <span class="fn"><span class="fn"><span class="fn">e</span> ∉ <span class="fn">I</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">e</span> <span class="fn">I</span>)</span></span></span></span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_compact : <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn">(∀ <span class="fn">J</span> ⊆ <span class="fn">I</span>, <span class="fn"><span class="fn"><span class="fn">J</span>.Finite</span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span></span>)</span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a> <span class="fn">α</span></span></div></div><p>An independence predicate satisfying the finite matroid axioms determines a matroid,
provided independence is determined by its behaviour on finite sets.
This fundamentally needs choice, since it can be used to prove that every vector space
has a basis.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-IndepMatroid.ofFinitary" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="IndepMatroid.ofFinitary_E"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L142-L142">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinitary_E"><span class="name">IndepMatroid</span>.<span class="name">ofFinitary_E</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug :
  <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span>.Finite</span> → <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">J</span>.Finite</span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">I</span>.ncard</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">J</span>.ncard</span></span> → <span class="fn">∃ <span class="fn">e</span> ∈ <span class="fn">J</span>, <span class="fn"><span class="fn"><span class="fn">e</span> ∉ <span class="fn">I</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">e</span> <span class="fn">I</span>)</span></span></span></span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_compact : <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn">(∀ <span class="fn">J</span> ⊆ <span class="fn">I</span>, <span class="fn"><span class="fn"><span class="fn">J</span>.Finite</span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span></span>)</span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinitary">IndepMatroid.ofFinitary</a> <span class="fn">E</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">indep_aug</span> <span class="fn">indep_compact</span> <span class="fn">subset_ground</span>)</span>.E</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">E</span></span></div></div></div></div><div class="decl" id="IndepMatroid.ofFinitary_indep"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L235-L237">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinitary_indep"><span class="name">IndepMatroid</span>.<span class="name">ofFinitary_indep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug :
  <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span>.Finite</span> → <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">J</span>.Finite</span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">I</span>.ncard</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">J</span>.ncard</span></span> → <span class="fn">∃ <span class="fn">e</span> ∈ <span class="fn">J</span>, <span class="fn"><span class="fn"><span class="fn">e</span> ∉ <span class="fn">I</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">e</span> <span class="fn">I</span>)</span></span></span></span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_compact : <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn">(∀ <span class="fn">J</span> ⊆ <span class="fn">I</span>, <span class="fn"><span class="fn"><span class="fn">J</span>.Finite</span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span></span>)</span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinitary">IndepMatroid.ofFinitary</a> <span class="fn">E</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">indep_aug</span> <span class="fn">indep_compact</span> <span class="fn">subset_ground</span>)</span>.Indep</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Indep</span></span></div></div></div></div><div class="decl" id="IndepMatroid.ofFinitary_finitary"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L239-L243">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinitary_finitary"><span class="name">IndepMatroid</span>.<span class="name">ofFinitary_finitary</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug :
  <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span>.Finite</span> → <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">J</span>.Finite</span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">I</span>.ncard</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">J</span>.ncard</span></span> → <span class="fn">∃ <span class="fn">e</span> ∈ <span class="fn">J</span>, <span class="fn"><span class="fn"><span class="fn">e</span> ∉ <span class="fn">I</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">e</span> <span class="fn">I</span>)</span></span></span></span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_compact : <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn">(∀ <span class="fn">J</span> ⊆ <span class="fn">I</span>, <span class="fn"><span class="fn"><span class="fn">J</span>.Finite</span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span></span>)</span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinitary">IndepMatroid.ofFinitary</a> <span class="fn">E</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">indep_aug</span> <span class="fn">indep_compact</span> <span class="fn">subset_ground</span>)</span>.matroid</span>.Finitary</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Matroid.existsMaximalSubsetProperty_of_bdd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L245-L265">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.existsMaximalSubsetProperty_of_bdd"><span class="name">Matroid</span>.<span class="name">existsMaximalSubsetProperty_of_bdd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hP : <span class="fn">∃ (<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>), <span class="fn">∀ (<span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">Y</span></span> → <span class="fn"><span class="fn"><span class="fn">Y</span>.encard</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">↑<span class="fn">n</span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid.ExistsMaximalSubsetProperty">Matroid.ExistsMaximalSubsetProperty</a> <span class="fn">P</span> <span class="fn">X</span></span></div></div><p>If there is an absolute upper bound on the size of a set satisfying <code>P</code>, then the
maximal subset property always holds.</p></div></div><div class="decl" id="IndepMatroid.ofBdd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L267-L282">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBdd"><span class="name">IndepMatroid</span>.<span class="name">ofBdd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#Maximal">Maximal</a> <span class="fn">Indep</span> <span class="fn">I</span></span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#Maximal">Maximal</a> <span class="fn">Indep</span> <span class="fn">B</span></span> → <span class="fn">∃ <span class="fn">x</span> ∈ <span class="fn"><span class="fn">B</span> <a href="../../.././Init/Core.html#SDiff.sdiff">\</a> <span class="fn">I</span></span>, <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">x</span> <span class="fn">I</span>)</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_bdd : <span class="fn">∃ (<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>), <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span>.encard</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">↑<span class="fn">n</span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a> <span class="fn">α</span></span></div></div><p>If there is an absolute upper bound on the size of an independent set, then the maximality axiom
isn't needed to define a matroid by independent sets.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-IndepMatroid.ofBdd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="IndepMatroid.ofBdd_E"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L269-L269">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBdd_E"><span class="name">IndepMatroid</span>.<span class="name">ofBdd_E</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#Maximal">Maximal</a> <span class="fn">Indep</span> <span class="fn">I</span></span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#Maximal">Maximal</a> <span class="fn">Indep</span> <span class="fn">B</span></span> → <span class="fn">∃ <span class="fn">x</span> ∈ <span class="fn"><span class="fn">B</span> <a href="../../.././Init/Core.html#SDiff.sdiff">\</a> <span class="fn">I</span></span>, <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">x</span> <span class="fn">I</span>)</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_bdd : <span class="fn">∃ (<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>), <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span>.encard</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">↑<span class="fn">n</span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBdd">IndepMatroid.ofBdd</a> <span class="fn">E</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">indep_aug</span> <span class="fn">subset_ground</span> <span class="fn">indep_bdd</span>)</span>.E</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">E</span></span></div></div></div></div><div class="decl" id="IndepMatroid.ofBdd_indep"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L284-L286">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBdd_indep"><span class="name">IndepMatroid</span>.<span class="name">ofBdd_indep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#Maximal">Maximal</a> <span class="fn">Indep</span> <span class="fn">I</span></span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#Maximal">Maximal</a> <span class="fn">Indep</span> <span class="fn">B</span></span> → <span class="fn">∃ <span class="fn">x</span> ∈ <span class="fn"><span class="fn">B</span> <a href="../../.././Init/Core.html#SDiff.sdiff">\</a> <span class="fn">I</span></span>, <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">x</span> <span class="fn">I</span>)</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h_bdd : <span class="fn">∃ (<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>), <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span>.encard</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">↑<span class="fn">n</span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBdd">IndepMatroid.ofBdd</a> <span class="fn">E</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">indep_aug</span> <span class="fn">subset_ground</span> <span class="fn">h_bdd</span>)</span>.Indep</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Indep</span></span></div></div></div></div><div class="decl" id="IndepMatroid.instFiniteRkMatroidOfBdd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L288-L295">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.instFiniteRkMatroidOfBdd"><span class="name">IndepMatroid</span>.<span class="name">instFiniteRkMatroidOfBdd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#Maximal">Maximal</a> <span class="fn">Indep</span> <span class="fn">I</span></span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#Maximal">Maximal</a> <span class="fn">Indep</span> <span class="fn">B</span></span> → <span class="fn">∃ <span class="fn">x</span> ∈ <span class="fn"><span class="fn">B</span> <a href="../../.././Init/Core.html#SDiff.sdiff">\</a> <span class="fn">I</span></span>, <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">x</span> <span class="fn">I</span>)</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h_bdd : <span class="fn">∃ (<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>), <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span>.encard</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">↑<span class="fn">n</span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBdd">IndepMatroid.ofBdd</a> <span class="fn">E</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">indep_aug</span> <span class="fn">subset_ground</span> <span class="fn">h_bdd</span>)</span>.matroid</span>.FiniteRk</span></div></div><p><code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBdd">IndepMatroid.ofBdd</a></code> constructs a <code>FiniteRk</code> matroid.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="IndepMatroid.ofBddAugment"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L297-L324">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBddAugment"><span class="name">IndepMatroid</span>.<span class="name">ofBddAugment</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">I</span>.encard</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">J</span>.encard</span></span> → <span class="fn">∃ <span class="fn">e</span> ∈ <span class="fn">J</span>, <span class="fn"><span class="fn"><span class="fn">e</span> ∉ <span class="fn">I</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">e</span> <span class="fn">I</span>)</span></span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_bdd : <span class="fn">∃ (<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>), <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span>.encard</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">↑<span class="fn">n</span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a> <span class="fn">α</span></span></div></div><p>If there is an absolute upper bound on the size of an independent set, then matroids
can be defined using an 'augmentation' axiom similar to the standard definition of
finite matroids for independent sets.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBddAugment">IndepMatroid.ofBddAugment</a> <span class="fn">E</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">indep_aug</span> <span class="fn">indep_bdd</span> <span class="fn">subset_ground</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBdd">IndepMatroid.ofBdd</a> <span class="fn">E</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">⋯</span> <span class="fn">subset_ground</span> <span class="fn">indep_bdd</span></span></span></li></ul></details><details id="instances-for-list-IndepMatroid.ofBddAugment" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="IndepMatroid.ofBddAugment_E"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L326-L328">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBddAugment_E"><span class="name">IndepMatroid</span>.<span class="name">ofBddAugment_E</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">I</span>.encard</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">J</span>.encard</span></span> → <span class="fn">∃ <span class="fn">e</span> ∈ <span class="fn">J</span>, <span class="fn"><span class="fn"><span class="fn">e</span> ∉ <span class="fn">I</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">e</span> <span class="fn">I</span>)</span></span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_bdd : <span class="fn">∃ (<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>), <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span>.encard</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">↑<span class="fn">n</span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBddAugment">IndepMatroid.ofBddAugment</a> <span class="fn">E</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">indep_aug</span> <span class="fn">indep_bdd</span> <span class="fn">subset_ground</span>)</span>.E</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">E</span></span></div></div></div></div><div class="decl" id="IndepMatroid.ofBddAugment_indep"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L330-L332">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBddAugment_indep"><span class="name">IndepMatroid</span>.<span class="name">ofBddAugment_indep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">I</span>.encard</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">J</span>.encard</span></span> → <span class="fn">∃ <span class="fn">e</span> ∈ <span class="fn">J</span>, <span class="fn"><span class="fn"><span class="fn">e</span> ∉ <span class="fn">I</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">e</span> <span class="fn">I</span>)</span></span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_bdd : <span class="fn">∃ (<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>), <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span>.encard</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">↑<span class="fn">n</span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBddAugment">IndepMatroid.ofBddAugment</a> <span class="fn">E</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">indep_aug</span> <span class="fn">indep_bdd</span> <span class="fn">subset_ground</span>)</span>.Indep</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Indep</span></span></div></div></div></div><div class="decl" id="IndepMatroid.ofBddAugment_finiteRk"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L334-L338">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBddAugment_finiteRk"><span class="name">IndepMatroid</span>.<span class="name">ofBddAugment_finiteRk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">I</span>.encard</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">J</span>.encard</span></span> → <span class="fn">∃ <span class="fn">e</span> ∈ <span class="fn">J</span>, <span class="fn"><span class="fn"><span class="fn">e</span> ∉ <span class="fn">I</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">e</span> <span class="fn">I</span>)</span></span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_bdd : <span class="fn">∃ (<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>), <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span>.encard</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">↑<span class="fn">n</span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBddAugment">IndepMatroid.ofBddAugment</a> <span class="fn">E</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">indep_aug</span> <span class="fn">indep_bdd</span> <span class="fn">subset_ground</span>)</span>.matroid</span>.FiniteRk</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="IndepMatroid.ofFinite"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L340-L357">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinite"><span class="name">IndepMatroid</span>.<span class="name">ofFinite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hE : <span class="fn"><span class="fn">E</span>.Finite</span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">I</span>.ncard</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">J</span>.ncard</span></span> → <span class="fn">∃ <span class="fn">e</span> ∈ <span class="fn">J</span>, <span class="fn"><span class="fn"><span class="fn">e</span> ∉ <span class="fn">I</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">e</span> <span class="fn">I</span>)</span></span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ ⦃<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a> <span class="fn">α</span></span></div></div><p>If <code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.E">E</a></code> is finite, then any collection of subsets of <code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.E">E</a></code> satisfying
the usual independence axioms determines a matroid</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinite">IndepMatroid.ofFinite</a> <span class="fn">hE</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">indep_aug</span> <span class="fn">subset_ground</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofBddAugment">IndepMatroid.ofBddAugment</a> <span class="fn">E</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">⋯</span> <span class="fn">⋯</span> <span class="fn">subset_ground</span></span></span></li></ul></details><details id="instances-for-list-IndepMatroid.ofFinite" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="IndepMatroid.ofFinite_E"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L359-L361">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinite_E"><span class="name">IndepMatroid</span>.<span class="name">ofFinite_E</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hE : <span class="fn"><span class="fn">E</span>.Finite</span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">I</span>.ncard</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">J</span>.ncard</span></span> → <span class="fn">∃ <span class="fn">e</span> ∈ <span class="fn">J</span>, <span class="fn"><span class="fn"><span class="fn">e</span> ∉ <span class="fn">I</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">e</span> <span class="fn">I</span>)</span></span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ ⦃<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinite">IndepMatroid.ofFinite</a> <span class="fn">hE</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">indep_aug</span> <span class="fn">subset_ground</span>)</span>.E</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">E</span></span></div></div></div></div><div class="decl" id="IndepMatroid.ofFinite_indep"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L363-L365">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinite_indep"><span class="name">IndepMatroid</span>.<span class="name">ofFinite_indep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hE : <span class="fn"><span class="fn">E</span>.Finite</span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">I</span>.ncard</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">J</span>.ncard</span></span> → <span class="fn">∃ <span class="fn">e</span> ∈ <span class="fn">J</span>, <span class="fn"><span class="fn"><span class="fn">e</span> ∉ <span class="fn">I</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">e</span> <span class="fn">I</span>)</span></span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ ⦃<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinite">IndepMatroid.ofFinite</a> <span class="fn">hE</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">indep_aug</span> <span class="fn">subset_ground</span>)</span>.Indep</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Indep</span></span></div></div></div></div><div class="decl" id="IndepMatroid.ofFinite_finite"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L367-L370">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinite_finite"><span class="name">IndepMatroid</span>.<span class="name">ofFinite_finite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hE : <span class="fn"><span class="fn">E</span>.Finite</span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">I</span>.ncard</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">J</span>.ncard</span></span> → <span class="fn">∃ <span class="fn">e</span> ∈ <span class="fn">J</span>, <span class="fn"><span class="fn"><span class="fn">e</span> ∉ <span class="fn">I</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">e</span> <span class="fn">I</span>)</span></span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ ⦃<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinite">IndepMatroid.ofFinite</a> <span class="fn">hE</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">indep_aug</span> <span class="fn">subset_ground</span>)</span>.matroid</span>.Finite</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="IndepMatroid.ofFinset"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L372-L392">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinset"><span class="name">IndepMatroid</span>.<span class="name">ofFinset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">I</span>.card</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">J</span>.card</span></span> → <span class="fn">∃ <span class="fn">e</span> ∈ <span class="fn">J</span>, <span class="fn"><span class="fn"><span class="fn">e</span> ∉ <span class="fn">I</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">e</span> <span class="fn">I</span>)</span></span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ ⦃<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">↑<span class="fn">I</span></span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid">IndepMatroid</a> <span class="fn">α</span></span></div></div><p>An independence predicate on <code><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> α</code> that obeys the finite matroid axioms determines a
finitary matroid on <code>α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinset">IndepMatroid.ofFinset</a> <span class="fn">E</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">indep_aug</span> <span class="fn">subset_ground</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinitary">IndepMatroid.ofFinitary</a> <span class="fn">E</span> <span class="fn">(fun (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn">∀ (<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">↑<span class="fn">J</span></span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">I</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span></span></span>)</span> <span class="fn">⋯</span> <span class="fn">⋯</span> <span class="fn">⋯</span> <span class="fn">⋯</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-IndepMatroid.ofFinset" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="IndepMatroid.ofFinset_E"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L394-L396">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinset_E"><span class="name">IndepMatroid</span>.<span class="name">ofFinset_E</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">I</span>.card</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">J</span>.card</span></span> → <span class="fn">∃ <span class="fn">e</span> ∈ <span class="fn">J</span>, <span class="fn"><span class="fn"><span class="fn">e</span> ∉ <span class="fn">I</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">e</span> <span class="fn">I</span>)</span></span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ ⦃<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">↑<span class="fn">I</span></span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinset">IndepMatroid.ofFinset</a> <span class="fn">E</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">indep_aug</span> <span class="fn">subset_ground</span>)</span>.E</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">E</span></span></div></div></div></div><div class="decl" id="IndepMatroid.ofFinset_indep"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L398-L402">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinset_indep"><span class="name">IndepMatroid</span>.<span class="name">ofFinset_indep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">I</span>.card</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">J</span>.card</span></span> → <span class="fn">∃ <span class="fn">e</span> ∈ <span class="fn">J</span>, <span class="fn"><span class="fn"><span class="fn">e</span> ∉ <span class="fn">I</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">e</span> <span class="fn">I</span>)</span></span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ ⦃<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">↑<span class="fn">I</span></span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinset">IndepMatroid.ofFinset</a> <span class="fn">E</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">indep_aug</span> <span class="fn">subset_ground</span>)</span>.Indep</span> <span class="fn">↑<span class="fn">I</span></span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></div></div></div></div><div class="decl" id="IndepMatroid.ofFinset_indep'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L404-L410">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinset_indep'"><span class="name">IndepMatroid</span>.<span class="name">ofFinset_indep'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_empty : <span class="fn"><span class="fn">Indep</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_subset : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn">I</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">J</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(indep_aug : <span class="fn">∀ ⦃<span class="fn">I </span><span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">I</span>.card</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">J</span>.card</span></span> → <span class="fn">∃ <span class="fn">e</span> ∈ <span class="fn">J</span>, <span class="fn"><span class="fn"><span class="fn">e</span> ∉ <span class="fn">I</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">e</span> <span class="fn">I</span>)</span></span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ ⦃<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span> → <span class="fn"><span class="fn">↑<span class="fn">I</span></span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{I : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.ofFinset">IndepMatroid.ofFinset</a> <span class="fn">E</span> <span class="fn">Indep</span> <span class="fn">indep_empty</span> <span class="fn">indep_subset</span> <span class="fn">indep_aug</span> <span class="fn">subset_ground</span>)</span>.Indep</span> <span class="fn">I</span></span> <a href="../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">↑<span class="fn">J</span></span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">I</span></span> → <span class="fn"><span class="fn">Indep</span> <span class="fn">J</span></span></span></span></span></div></div><p>This can't be <code>@[simp]</code>, because it would cause the more useful
<code>Matroid.ofIndepFinset_apply</code> not to be in simp normal form.</p></div></div><div class="decl" id="Matroid.ofExistsMatroid"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L418-L432">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofExistsMatroid"><span class="name">Matroid</span>.<span class="name">ofExistsMatroid</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(hM : <span class="fn">∃ (<span class="fn">M</span> : <span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">E</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">M</span>.E</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">M</span>.Indep</span> <span class="fn">I</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a> <span class="fn">α</span></span></div></div><p>Construct an <code><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a></code> from an independence predicate that agrees with that of some matroid <code>M</code>.
This is computable even if <code>M</code> is only known existentially, or when <code>M</code> exists for different
reasons in different cases. This can also be used to change the independence predicate to a
more useful definitional form.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofExistsMatroid">Matroid.ofExistsMatroid</a> <span class="fn">E</span> <span class="fn">Indep</span> <span class="fn">hM</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(let_fun <span class="fn">hex</span> := <span class="fn">⋯</span>;
    <span class="fn">{ <span class="fn">E</span> := <span class="fn">E</span>, <span class="fn">Indep</span> := <span class="fn">Indep</span>, <span class="fn">indep_empty</span> := <span class="fn">⋯</span>, <span class="fn">indep_subset</span> := <span class="fn">⋯</span>, <span class="fn">indep_aug</span> := <span class="fn">⋯</span>, <span class="fn">indep_maximal</span> := <span class="fn">⋯</span>,
      <span class="fn">subset_ground</span> := <span class="fn">⋯</span> }</span>)</span>.matroid</span></span></li></ul></details><details id="instances-for-list-Matroid.ofExistsMatroid" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Matroid.ofExistsMatroid_E"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L422-L422">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofExistsMatroid_E"><span class="name">Matroid</span>.<span class="name">ofExistsMatroid_E</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Indep : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(hM : <span class="fn">∃ (<span class="fn">M</span> : <span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">E</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">M</span>.E</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">M</span>.Indep</span> <span class="fn">I</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">Indep</span> <span class="fn">I</span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofExistsMatroid">Matroid.ofExistsMatroid</a> <span class="fn">E</span> <span class="fn">Indep</span> <span class="fn">hM</span>)</span>.E</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">E</span></span></div></div></div></div><div class="decl" id="Matroid.ofBase"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L434-L446">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofBase"><span class="name">Matroid</span>.<span class="name">ofBase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Base : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(exists_base : <span class="fn">∃ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(base_exchange : <span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid.ExchangeProperty">Matroid.ExchangeProperty</a> <span class="fn">Base</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(maximality : <span class="fn">∀ <span class="fn">X</span> ⊆ <span class="fn">E</span>, <span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid.ExistsMaximalSubsetProperty">Matroid.ExistsMaximalSubsetProperty</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn">∃ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">B</span></span></span></span>)</span> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span> → <span class="fn"><span class="fn">B</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a> <span class="fn">α</span></span></div></div><p>A matroid defined purely in terms of its bases.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Matroid.ofBase" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Matroid.ofBase_E"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L435-L435">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofBase_E"><span class="name">Matroid</span>.<span class="name">ofBase_E</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Base : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(exists_base : <span class="fn">∃ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(base_exchange : <span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid.ExchangeProperty">Matroid.ExchangeProperty</a> <span class="fn">Base</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(maximality : <span class="fn">∀ <span class="fn">X</span> ⊆ <span class="fn">E</span>, <span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid.ExistsMaximalSubsetProperty">Matroid.ExistsMaximalSubsetProperty</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn">∃ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">B</span></span></span></span>)</span> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span> → <span class="fn"><span class="fn">B</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofBase">Matroid.ofBase</a> <span class="fn">E</span> <span class="fn">Base</span> <span class="fn">exists_base</span> <span class="fn">base_exchange</span> <span class="fn">maximality</span> <span class="fn">subset_ground</span>)</span>.E</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">E</span></span></div></div></div></div><div class="decl" id="Matroid.ofExistsFiniteBase"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L448-L462">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofExistsFiniteBase"><span class="name">Matroid</span>.<span class="name">ofExistsFiniteBase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Base : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(exists_finite_base : <span class="fn">∃ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">B</span>.Finite</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(base_exchange : <span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid.ExchangeProperty">Matroid.ExchangeProperty</a> <span class="fn">Base</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span> → <span class="fn"><span class="fn">B</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a> <span class="fn">α</span></span></div></div><p>A collection of bases with the exchange property and at least one finite member is a matroid</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofExistsFiniteBase">Matroid.ofExistsFiniteBase</a> <span class="fn">E</span> <span class="fn">Base</span> <span class="fn">exists_finite_base</span> <span class="fn">base_exchange</span> <span class="fn">subset_ground</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofBase">Matroid.ofBase</a> <span class="fn">E</span> <span class="fn">Base</span> <span class="fn">⋯</span> <span class="fn">base_exchange</span> <span class="fn">⋯</span> <span class="fn">subset_ground</span></span></span></li></ul></details><details id="instances-for-list-Matroid.ofExistsFiniteBase" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Matroid.ofExistsFiniteBase_E"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L449-L449">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofExistsFiniteBase_E"><span class="name">Matroid</span>.<span class="name">ofExistsFiniteBase_E</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Base : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(exists_finite_base : <span class="fn">∃ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">B</span>.Finite</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(base_exchange : <span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid.ExchangeProperty">Matroid.ExchangeProperty</a> <span class="fn">Base</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span> → <span class="fn"><span class="fn">B</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofExistsFiniteBase">Matroid.ofExistsFiniteBase</a> <span class="fn">E</span> <span class="fn">Base</span> <span class="fn">exists_finite_base</span> <span class="fn">base_exchange</span> <span class="fn">subset_ground</span>)</span>.E</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">E</span></span></div></div></div></div><div class="decl" id="Matroid.ofExistsFiniteBase_base"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L464-L466">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofExistsFiniteBase_base"><span class="name">Matroid</span>.<span class="name">ofExistsFiniteBase_base</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Base : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(exists_finite_base : <span class="fn">∃ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">B</span>.Finite</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(base_exchange : <span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid.ExchangeProperty">Matroid.ExchangeProperty</a> <span class="fn">Base</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span> → <span class="fn"><span class="fn">B</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofExistsFiniteBase">Matroid.ofExistsFiniteBase</a> <span class="fn">E</span> <span class="fn">Base</span> <span class="fn">exists_finite_base</span> <span class="fn">base_exchange</span> <span class="fn">subset_ground</span>)</span>.Base</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Base</span></span></div></div></div></div><div class="decl" id="Matroid.ofExistsFiniteBase_finiteRk"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L468-L472">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofExistsFiniteBase_finiteRk"><span class="name">Matroid</span>.<span class="name">ofExistsFiniteBase_finiteRk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Base : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(exists_finite_base : <span class="fn">∃ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">B</span>.Finite</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(base_exchange : <span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid.ExchangeProperty">Matroid.ExchangeProperty</a> <span class="fn">Base</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span> → <span class="fn"><span class="fn">B</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofExistsFiniteBase">Matroid.ofExistsFiniteBase</a> <span class="fn">E</span> <span class="fn">Base</span> <span class="fn">exists_finite_base</span> <span class="fn">base_exchange</span> <span class="fn">subset_ground</span>)</span>.FiniteRk</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Matroid.ofBaseOfFinite"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L474-L484">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofBaseOfFinite"><span class="name">Matroid</span>.<span class="name">ofBaseOfFinite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hE : <span class="fn"><span class="fn">E</span>.Finite</span>)</span></span>
<span class="decl_args">
<span class="fn">(Base : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(exists_base : <span class="fn">∃ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(base_exchange : <span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid.ExchangeProperty">Matroid.ExchangeProperty</a> <span class="fn">Base</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span> → <span class="fn"><span class="fn">B</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid">Matroid</a> <span class="fn">α</span></span></div></div><p>If <code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.E">E</a></code> is finite, then any nonempty collection of its subsets
with the exchange property is the collection of bases of a matroid on <code><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#IndepMatroid.E">E</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofBaseOfFinite">Matroid.ofBaseOfFinite</a> <span class="fn">hE</span> <span class="fn">Base</span> <span class="fn">exists_base</span> <span class="fn">base_exchange</span> <span class="fn">subset_ground</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofExistsFiniteBase">Matroid.ofExistsFiniteBase</a> <span class="fn">E</span> <span class="fn">Base</span> <span class="fn">⋯</span> <span class="fn">base_exchange</span> <span class="fn">subset_ground</span></span></span></li></ul></details><details id="instances-for-list-Matroid.ofBaseOfFinite" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Matroid.ofBaseOfFinite_E"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L486-L488">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofBaseOfFinite_E"><span class="name">Matroid</span>.<span class="name">ofBaseOfFinite_E</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hE : <span class="fn"><span class="fn">E</span>.Finite</span>)</span></span>
<span class="decl_args">
<span class="fn">(Base : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(exists_base : <span class="fn">∃ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(base_exchange : <span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid.ExchangeProperty">Matroid.ExchangeProperty</a> <span class="fn">Base</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span> → <span class="fn"><span class="fn">B</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofBaseOfFinite">Matroid.ofBaseOfFinite</a> <span class="fn">hE</span> <span class="fn">Base</span> <span class="fn">exists_base</span> <span class="fn">base_exchange</span> <span class="fn">subset_ground</span>)</span>.E</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">E</span></span></div></div></div></div><div class="decl" id="Matroid.ofBaseOfFinite_base"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L490-L492">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofBaseOfFinite_base"><span class="name">Matroid</span>.<span class="name">ofBaseOfFinite_base</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hE : <span class="fn"><span class="fn">E</span>.Finite</span>)</span></span>
<span class="decl_args">
<span class="fn">(Base : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(exists_base : <span class="fn">∃ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(base_exchange : <span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid.ExchangeProperty">Matroid.ExchangeProperty</a> <span class="fn">Base</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span> → <span class="fn"><span class="fn">B</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofBaseOfFinite">Matroid.ofBaseOfFinite</a> <span class="fn">hE</span> <span class="fn">Base</span> <span class="fn">exists_base</span> <span class="fn">base_exchange</span> <span class="fn">subset_ground</span>)</span>.Base</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Base</span></span></div></div></div></div><div class="decl" id="Matroid.ofBaseOfFinite_finite"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/Data/Matroid/IndepAxioms.lean#L494-L497">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofBaseOfFinite_finite"><span class="name">Matroid</span>.<span class="name">ofBaseOfFinite_finite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hE : <span class="fn"><span class="fn">E</span>.Finite</span>)</span></span>
<span class="decl_args">
<span class="fn">(Base : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(exists_base : <span class="fn">∃ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(base_exchange : <span class="fn"><a href="../../.././Mathlib/Data/Matroid/Basic.html#Matroid.ExchangeProperty">Matroid.ExchangeProperty</a> <span class="fn">Base</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(subset_ground : <span class="fn">∀ (<span class="fn">B</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">Base</span> <span class="fn">B</span></span> → <span class="fn"><span class="fn">B</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">E</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Matroid/IndepAxioms.html#Matroid.ofBaseOfFinite">Matroid.ofBaseOfFinite</a> <span class="fn">hE</span> <span class="fn">Base</span> <span class="fn">exists_base</span> <span class="fn">base_exchange</span> <span class="fn">subset_ground</span>)</span>.Finite</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>