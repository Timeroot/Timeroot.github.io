<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Comma.Over</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Comma.Over";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Comma</span>.<span class="name">Over</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/CategoryTheory/Category/Cat.html">Mathlib.CategoryTheory.Category.Cat</a></li><li><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html">Mathlib.CategoryTheory.Comma.StructuredArrow.Basic</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Comma.Over" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over"><span class="name">CategoryTheory</span>.<span class="name">Over</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instCategoryOver"><span class="name">CategoryTheory</span>.<span class="name">instCategoryOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.inhabited"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">inhabited</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.OverMorphism.ext"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">OverMorphism</span>.<span class="name">ext</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.over_right"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">over_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.id_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">id_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.comp_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">comp_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.comp_left_assoc"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">comp_left_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.w"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">w</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">w_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mk"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mk_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mk_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mk_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mk_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.coeFromHom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">coeFromHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.coe_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">coe_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.homMk"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">homMk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.homMk_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">homMk_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.homMk_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">homMk_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.isoMk"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.isoMk_hom_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_hom_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.isoMk_hom_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_hom_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.isoMk_inv_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_inv_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.isoMk_inv_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_inv_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.hom_left_inv_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">hom_left_inv_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.hom_left_inv_left_assoc"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">hom_left_inv_left_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.inv_left_hom_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">inv_left_hom_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.inv_left_hom_left_assoc"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">inv_left_hom_left_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forget_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forget_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forgetCocone"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forgetCocone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forgetCocone_pt"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forgetCocone_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forgetCocone_ι_app"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forgetCocone_ι_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.map_obj_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map_obj_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.map_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.map_map_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map_map_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapIso_functor"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapIso_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapIso_inverse"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapIso_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapId_eq"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapId_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapId"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapId_inv"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapId_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapId_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapId_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapForget_eq"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapForget_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapForget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapForget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.eqToHom_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">eqToHom_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapComp_eq"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapComp_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapComp"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapComp_inv"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapComp_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapComp_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapComp_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapCongr"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapCongr</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapCongr_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapCongr_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapCongr_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapCongr_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapFunctor"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapFunctor_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapFunctor_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapFunctor_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapFunctor_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forget_reflects_iso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_reflects_iso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mkIdTerminal"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mkIdTerminal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forget_faithful"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_faithful</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.epi_of_epi_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">epi_of_epi_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mono_of_mono_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mono_of_mono_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mono_left_of_mono"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mono_left_of_mono</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceForward"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceForward_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceForward_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceBackward"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceBackward_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceBackward_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceEquiv"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceEquiv_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceEquiv_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceEquiv_functor"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceEquiv_inverse"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceForward_forget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward_forget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceBackward_forget_forget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward_forget_forget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.post"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.post_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.post_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.post_comp"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.postComp"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.postComp_hom_app_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postComp_hom_app_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.postComp_inv_app_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postComp_inv_app_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.postComp_inv_app_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postComp_inv_app_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.postComp_hom_app_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postComp_hom_app_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.postMap"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postMap</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.postMap_app"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postMap_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.postCongr"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postCongr</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.postCongr_inv_app_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postCongr_inv_app_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.postCongr_hom_app_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postCongr_hom_app_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.postCongr_hom_app_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postCongr_hom_app_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.postCongr_inv_app_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postCongr_inv_app_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.instFaithfulObjPost"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">instFaithfulObjPost</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.instFullObjPostOfFaithful"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">instFullObjPostOfFaithful</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.instEssSurjObjPostOfFull"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">instEssSurjObjPostOfFull</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.instIsEquivalenceObjPost"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">instIsEquivalenceObjPost</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.postEquiv"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.postEquiv_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postEquiv_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.postEquiv_inverse"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postEquiv_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.postEquiv_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postEquiv_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.postEquiv_functor"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postEquiv_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.toOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.toOver_map_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_map_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.toOver_map_right"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_map_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.toOver_obj_right"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_obj_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.toOver_obj_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_obj_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.toOver_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.instFaithfulOverToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">instFaithfulOverToOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.instFullOverToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">instFullOverToOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.instEssSurjOverToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">instEssSurjOverToOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.isEquivalence_toOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">isEquivalence_toOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under"><span class="name">CategoryTheory</span>.<span class="name">Under</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instCategoryUnder"><span class="name">CategoryTheory</span>.<span class="name">instCategoryUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.inhabited"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">inhabited</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.UnderMorphism.ext"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">UnderMorphism</span>.<span class="name">ext</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.under_left"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">under_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.id_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">id_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.comp_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">comp_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.w"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">w</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">w_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mk"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mk_hom"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mk_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mk_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mk_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.homMk"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">homMk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.homMk_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">homMk_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.homMk_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">homMk_left_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.isoMk"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">isoMk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.isoMk_hom_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">isoMk_hom_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.isoMk_inv_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">isoMk_inv_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.hom_right_inv_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">hom_right_inv_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.hom_right_inv_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">hom_right_inv_right_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.inv_right_hom_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">inv_right_hom_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.inv_right_hom_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">inv_right_hom_right_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forget"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forget_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forget_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forgetCone"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forgetCone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forgetCone_pt"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forgetCone_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forgetCone_π_app"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forgetCone_π_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.map_obj_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map_obj_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.map_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.map_map_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map_map_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapIso"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapIso_functor"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapIso_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapIso_inverse"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapIso_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapId_eq"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapId_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapId"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapId_hom"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapId_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapId_inv"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapId_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapForget_eq"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapForget_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapForget"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapForget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.eqToHom_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">eqToHom_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapComp_eq"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapComp_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapComp"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapComp_inv"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapComp_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapComp_hom"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapComp_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapCongr"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapCongr</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapCongr_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapCongr_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapCongr_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapCongr_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapFunctor"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapFunctor_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapFunctor_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapFunctor_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapFunctor_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forget_reflects_iso"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_reflects_iso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mkIdInitial"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mkIdInitial</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forget_faithful"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_faithful</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mono_of_mono_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mono_of_mono_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.epi_of_epi_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">epi_of_epi_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.epi_right_of_epi"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">epi_right_of_epi</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.post"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.post_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.post_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.post_comp"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.postComp"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.postComp_inv_app_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postComp_inv_app_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.postComp_hom_app_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postComp_hom_app_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.postComp_hom_app_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postComp_hom_app_left_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.postComp_inv_app_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postComp_inv_app_left_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.postMap"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postMap</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.postMap_app"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postMap_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.postCongr"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postCongr</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.postCongr_hom_app_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postCongr_hom_app_left_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.postCongr_hom_app_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postCongr_hom_app_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.postCongr_inv_app_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postCongr_inv_app_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.postCongr_inv_app_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postCongr_inv_app_left_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.instFaithfulObjPost"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">instFaithfulObjPost</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.instFullObjPostOfFaithful"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">instFullObjPostOfFaithful</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.instEssSurjObjPostOfFull"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">instEssSurjObjPostOfFull</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.instIsEquivalenceObjPost"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">instIsEquivalenceObjPost</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.postEquiv"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.postEquiv_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postEquiv_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.postEquiv_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postEquiv_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.postEquiv_inverse"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postEquiv_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.postEquiv_functor"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postEquiv_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.toUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.toUnder_map_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_map_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.toUnder_obj_left"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_obj_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.toUnder_obj_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_obj_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.toUnder_map_left"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_map_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.toUnder_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.instFaithfulUnderToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">instFaithfulUnderToUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.instFullUnderToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">instFullUnderToUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.instEssSurjUnderToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">instEssSurjUnderToUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.isEquivalence_toUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">isEquivalence_toUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toOver"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toOver_obj_left"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver_obj_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toOver_map_left"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver_map_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toOverCompForget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOverCompForget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toOver_comp_forget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver_comp_forget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toUnder"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toUnder_map_right"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder_map_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toUnder_obj_right"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder_obj_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toUnderCompForget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnderCompForget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toUnder_comp_forget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder_comp_forget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">functor_obj_right_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">functor_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_right_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">functor_map_right_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">functor_obj_right_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">functor_map_left_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_left_as"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">functor_obj_right_left_as</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_right_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">functor_map_right_left_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_left_as"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">functor_obj_left_as</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_right_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">inverse_map_right_left_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_left_as"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_right_left_as</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_right_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_right_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">inverse_map_right_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">inverse_map_left_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_right_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_left_as"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_left_as</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_right_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_right_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_map_right_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_map_right_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_right_left_as"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_right_left_as</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_right_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_right_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_map_right_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_map_right_left_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_left_as"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_left_as</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_map_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_map_left_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_obj_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_obj_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_map_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_map_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_map_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_map_left_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_obj_left_as"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_obj_left_as</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofDiagEquivalence"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.ofDiagEquivalence'"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">functor_obj_left_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_map_left_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">functor_map_left_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">functor_obj_left_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">functor_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_map_left_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">functor_map_left_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_right_as"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">functor_obj_left_right_as</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_right_as"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">functor_obj_right_as</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_map_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">functor_map_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_map_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">inverse_map_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_map_left_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">inverse_map_left_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_right_as"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_right_as</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_right_as"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_left_right_as</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_left_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_map_left_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">inverse_map_left_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_left_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_map_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_map_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_map_left_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_map_left_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_left_right_as"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_left_right_as</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_map_left_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_map_left_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_left_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_left_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_left_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_left_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_right_as"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_right_as</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_map_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_map_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_obj_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_obj_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_map_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_map_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_obj_right_as"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_obj_right_as</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofDiagEquivalence"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.ofDiagEquivalence'"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.opToOpUnder"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opToOpUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.opToOpUnder_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opToOpUnder_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.opToOpUnder_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opToOpUnder_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.opToOverOp"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opToOverOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.opToOverOp_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opToOverOp_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.opToOverOp_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opToOverOp_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.opEquivOpUnder"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opEquivOpUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.opEquivOpUnder_functor"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opEquivOpUnder_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.opEquivOpUnder_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opEquivOpUnder_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.opEquivOpUnder_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opEquivOpUnder_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.opEquivOpUnder_inverse"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opEquivOpUnder_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.opToOpOver"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opToOpOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.opToOpOver_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opToOpOver_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.opToOpOver_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opToOpOver_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.opToUnderOp"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opToUnderOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.opToUnderOp_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opToUnderOp_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.opToUnderOp_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opToUnderOp_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.opEquivOpOver"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opEquivOpOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.opEquivOpOver_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opEquivOpOver_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.opEquivOpOver_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opEquivOpOver_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.opEquivOpOver_functor"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opEquivOpOver_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.opEquivOpOver_inverse"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opEquivOpOver_inverse</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Over-and-under-categories">Over and under categories <a class="hover-link" href="#Over-and-under-categories">#</a></h1><p>Over (and under) categories are special cases of comma categories.</p><ul>
<li>If <code>L</code> is the identity functor and <code>R</code> is a constant functor, then <code>Comma L R</code> is the &quot;slice&quot; or
&quot;over&quot; category over the object <code>R</code> maps to.</li>
<li>Conversely, if <code>L</code> is a constant functor and <code>R</code> is the identity functor, then <code>Comma L R</code> is the
&quot;coslice&quot; or &quot;under&quot; category under the object <code>L</code> maps to.</li>
</ul><h2 class="markdown-heading" id="Tags">Tags <a class="hover-link" href="#Tags">#</a></h2><p>Comma, Slice, Coslice, Over, Under</p></div><div class="decl" id="CategoryTheory.Over"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L32-L38">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over"><span class="name">CategoryTheory</span>.<span class="name">Over</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max u₁ v₁)</div></div><p>The over category has as objects arrows in <code>T</code> with codomain <code>X</code> and as morphisms commutative
triangles.</p><p>See <a href="https://stacks.math.columbia.edu/tag/001G">https://stacks.math.columbia.edu/tag/001G</a>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span> <span class="fn">X</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.instCategoryOver"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L40-L40">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.instCategoryOver"><span class="name">CategoryTheory</span>.<span class="name">instCategoryOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, max u₁ v₁}</a>            <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.instCategoryOver">CategoryTheory.instCategoryOver</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">CategoryTheory.commaCategory</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.inhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L43-L47">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.inhabited"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">inhabited</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">default</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Over.inhabited</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{
    <span class="fn">default</span> :=
      <span class="fn">{ <span class="fn">left</span> := <span class="fn">default</span>, <span class="fn">right</span> := <span class="fn">default</span>,
        <span class="fn">hom</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span>.obj</span> <span class="fn">default</span>)</span></span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.OverMorphism.ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L53-L53">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.OverMorphism.ext"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">OverMorphism</span>.<span class="name">ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><span class="fn">U</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.left</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.over_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L60-L61">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.over_right"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">over_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">U</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">as</span> := <a href="../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a> }</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.id_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L63-L65">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.id_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">id_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">U</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">U</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.comp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L67-L69">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.comp_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">comp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a b c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.left</span> <span class="fn"><span class="fn">g</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.comp_left_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L67-L67">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.comp_left_assoc"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">comp_left_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a b c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">c</span>.left</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span>.left</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.left</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">g</span>.left</span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.w"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L71-L72">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.w"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">w</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A B : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.left</span> <span class="fn"><span class="fn">B</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">A</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.w_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L71-L71">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">w_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A B : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn"><span class="fn">B</span>.right</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.left</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">B</span>.hom</span> <span class="fn">h</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">A</span>.hom</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L74-L77">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span></div></div><p>To give an object in the over category, it suffices to give a morphism with codomain <code>X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mk">CategoryTheory.CostructuredArrow.mk</a> <span class="fn">f</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.mk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.mk_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L75-L75">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mk_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">f</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Y</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mk_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L75-L75">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mk_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">f</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.coeFromHom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L79-L81">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.coeFromHom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">coeFromHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Coe.html#CoeOut">CoeOut</a> <span class="fn">(<span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span>)</span></span></div></div><p>We can set up a coercion from arrows with codomain <code>X</code> to <code>over X</code>. This most likely should not
be a global instance, but it is sometimes useful.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Over.coeFromHom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">coe</span> := <span class="fn">CategoryTheory.Over.mk</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.coeFromHom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.coe_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L87-L89">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.coe_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">coe_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">f</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.homMk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L93-L97">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">homMk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">U</span>.left</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">V</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn"><span class="fn">V</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.hom</span></span> := by aesop_cat)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">U</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span></div></div><p>To give a morphism in the over category, it suffices to give an arrow fitting in a commutative
triangle.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn">f</span> <span class="fn">w</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.homMk">CategoryTheory.CostructuredArrow.homMk</a> <span class="fn">f</span> <span class="fn">w</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.homMk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.homMk_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L95-L95">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">homMk_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">U</span>.left</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">V</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn"><span class="fn">V</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.hom</span></span> := by aesop_cat)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn">f</span> <span class="fn">w</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.homMk_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L95-L95">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">homMk_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">U</span>.left</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">V</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn"><span class="fn">V</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.hom</span></span> := by aesop_cat)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.isoMk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L102-L108">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">hl</span>.hom</span> <span class="fn"><span class="fn">g</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span> := by aesop_cat)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">g</span></span></div></div><p>Construct an isomorphism in the over category given isomorphisms of the objects whose forward
direction gives a commutative triangle.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a> <span class="fn">hl</span> <span class="fn">hw</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.isoMk">CategoryTheory.CostructuredArrow.isoMk</a> <span class="fn">hl</span> <span class="fn">hw</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.isoMk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.isoMk_hom_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L105-L105">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk_hom_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_hom_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">hl</span>.hom</span> <span class="fn"><span class="fn">g</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span> := by aesop_cat)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.isoMk_hom_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L105-L105">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk_hom_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_hom_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">hl</span>.hom</span> <span class="fn"><span class="fn">g</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span> := by aesop_cat)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a> <span class="fn">hl</span> <span class="fn">hw</span>)</span>.hom</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">hl</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.isoMk_inv_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L105-L105">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk_inv_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_inv_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">hl</span>.hom</span> <span class="fn"><span class="fn">g</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span> := by aesop_cat)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.isoMk_inv_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L105-L105">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk_inv_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_inv_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">hl</span>.hom</span> <span class="fn"><span class="fn">g</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span> := by aesop_cat)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a> <span class="fn">hl</span> <span class="fn">hw</span>)</span>.inv</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">hl</span>.inv</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.hom_left_inv_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L113-L116">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.hom_left_inv_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">hom_left_inv_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn"><span class="fn">e</span>.hom</span>.left</span> <span class="fn"><span class="fn"><span class="fn">e</span>.inv</span>.left</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">f</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.hom_left_inv_left_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L113-L113">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.hom_left_inv_left_assoc"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">hom_left_inv_left_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn"><span class="fn">e</span>.hom</span>.left</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn"><span class="fn">e</span>.inv</span>.left</span> <span class="fn">h</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.inv_left_hom_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L118-L121">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.inv_left_hom_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">inv_left_hom_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn"><span class="fn">e</span>.inv</span>.left</span> <span class="fn"><span class="fn"><span class="fn">e</span>.hom</span>.left</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">g</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.inv_left_hom_left_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L118-L118">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.inv_left_hom_left_assoc"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">inv_left_hom_left_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">g</span>.left</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn"><span class="fn">e</span>.inv</span>.left</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn"><span class="fn">e</span>.hom</span>.left</span> <span class="fn">h</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.forget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L127-L132">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span>)</span> <span class="fn">T</span></span></div></div><p>The forgetful functor mapping an arrow to its domain.</p><p>See <a href="https://stacks.math.columbia.edu/tag/001G">https://stacks.math.columbia.edu/tag/001G</a>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.fst">CategoryTheory.Comma.fst</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.forget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.forget_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L136-L138">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">U</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.forget_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L140-L142">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">U</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.forgetCocone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L144-L148">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forgetCocone"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forgetCocone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span></span></div></div><p>The natural cocone over the forgetful functor <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> X ⥤ T</code> with cocone point <code>X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forgetCocone">CategoryTheory.Over.forgetCocone</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn">X</span>, <span class="fn">ι</span> := <span class="fn">{ <span class="fn">app</span> := <span class="fn">CategoryTheory.Comma.hom</span>, <span class="fn">naturality</span> := <span class="fn">⋯</span> }</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.forgetCocone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.forgetCocone_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L145-L145">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forgetCocone_pt"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forgetCocone_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forgetCocone">CategoryTheory.Over.forgetCocone</a> <span class="fn">X</span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">X</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.forgetCocone_ι_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L145-L145">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forgetCocone_ι_app"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forgetCocone_ι_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forgetCocone">CategoryTheory.Over.forgetCocone</a> <span class="fn">X</span>)</span>.ι</span>.app</span> <span class="fn">self</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">self</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L150-L155">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">Y</span>)</span></span></div></div><p>A morphism <code>f : X ⟶ Y</code> induces a functor <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> X ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> Y</code> in the obvious way.</p><p>See <a href="https://stacks.math.columbia.edu/tag/001G">https://stacks.math.columbia.edu/tag/001G</a>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.mapRight">CategoryTheory.Comma.mapRight</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span>
    <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans">CategoryTheory.Discrete.natTrans</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <a href="../../.././Init/Prelude.html#PUnit">PUnit.{1}</a></span>) =&gt; <span class="fn">f</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.map_obj_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L161-L163">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map_obj_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map_obj_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span>)</span>.obj</span> <span class="fn">U</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.map_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L165-L167">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span>)</span>.obj</span> <span class="fn">U</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">U</span>.hom</span> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.map_map_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L169-L171">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map_map_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map_map_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">U</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span>)</span>.map</span> <span class="fn">g</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mapIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L174-L176">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">Y</span></span></span></div></div><p>If <code>f</code> is an isomorphism, <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">map</a> f</code> is an equivalence of categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapIso">CategoryTheory.Over.mapIso</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.mapRightIso">CategoryTheory.Comma.mapRightIso</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span>
    <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso">CategoryTheory.Discrete.natIso</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <a href="../../.././Init/Prelude.html#PUnit">PUnit.{1}</a></span>) =&gt; <span class="fn">f</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.mapIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.mapIso_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L178-L178">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapIso_functor"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapIso_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapIso">CategoryTheory.Over.mapIso</a> <span class="fn">f</span>)</span>.functor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn"><span class="fn">f</span>.hom</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mapIso_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L179-L179">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapIso_inverse"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapIso_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapIso">CategoryTheory.Over.mapIso</a> <span class="fn">f</span>)</span>.inverse</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn"><span class="fn">f</span>.inv</span></span></span></div></div></div></div><div class="mod_doc"><p>This section proves various equalities between functors that
demonstrate, for instance, that over categories assemble into a
functor <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapFunctor">mapFunctor</a> : T ⥤ Cat</code>.</p><p>These equalities between functors are then converted to natural
isomorphisms using <code>eqToIso</code>. Such natural isomorphisms could be
obtained directly using <code>Iso.<a href="../../.././Mathlib/Order/Defs/Unbundled.html#refl">refl</a></code> but this method will have
better computational properties, when used, for instance, in
developing the theory of Beck-Chevalley transformations.</p></div><div class="decl" id="CategoryTheory.Over.mapId_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L194-L203">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapId_eq"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapId_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">Y</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">Y</span>)</span></span></span></div></div><p>Mapping by the identity morphism is just the identity functor.</p></div></div><div class="decl" id="CategoryTheory.Over.mapId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L205-L207">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapId"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapId</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">Y</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">Y</span>)</span></span></span></div></div><p>The natural isomorphism arising from <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapForget_eq">mapForget_eq</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapId">CategoryTheory.Over.mapId</a> <span class="fn">Y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso">CategoryTheory.eqToIso</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.mapId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.mapId_inv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L206-L206">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapId_inv"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapId_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapId">CategoryTheory.Over.mapId</a> <span class="fn">Y</span>)</span>.inv</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mapId_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L206-L206">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapId_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapId_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapId">CategoryTheory.Over.mapId</a> <span class="fn">Y</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mapForget_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L210-L215">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapForget_eq"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapForget_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">Y</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span></span></div></div><p>Mapping by <code>f</code> and then forgetting is the same as forgetting.</p></div></div><div class="decl" id="CategoryTheory.Over.mapForget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L217-L219">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapForget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapForget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">Y</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span></span></div></div><p>The natural isomorphism arising from <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapForget_eq">mapForget_eq</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapForget">CategoryTheory.Over.mapForget</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso">CategoryTheory.eqToIso</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.mapForget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.eqToHom_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L221-L224">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.eqToHom_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">eqToHom_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">U</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">V</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">e</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mapComp_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L226-L233">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapComp_eq"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapComp_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">g</span>)</span></span></span></div></div><p>Mapping by the composite morphism <code>f ≫ g</code> is the same as mapping by <code>f</code> then by <code>g</code>.</p></div></div><div class="decl" id="CategoryTheory.Over.mapComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L235-L238">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapComp"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">g</span>)</span></span></span></div></div><p>The natural isomorphism arising from <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapComp_eq">mapComp_eq</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapComp">CategoryTheory.Over.mapComp</a> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso">CategoryTheory.eqToIso</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.mapComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.mapComp_inv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L236-L236">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapComp_inv"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapComp_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapComp">CategoryTheory.Over.mapComp</a> <span class="fn">f</span> <span class="fn">g</span>)</span>.inv</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mapComp_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L236-L236">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapComp_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapComp_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapComp">CategoryTheory.Over.mapComp</a> <span class="fn">f</span> <span class="fn">g</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mapCongr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L240-L244">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapCongr"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapCongr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f g : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">g</span></span></span></div></div><p>If <code>f = g</code>, then <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">map</a> f</code> is naturally isomorphic to <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">map</a> g</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapCongr">CategoryTheory.Over.mapCongr</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a> <span class="fn">(fun (<span class="fn">A</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso">CategoryTheory.eqToIso</a> <span class="fn">⋯</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.mapCongr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.mapCongr_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L241-L241">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapCongr_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapCongr_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f g : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapCongr">CategoryTheory.Over.mapCongr</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span>)</span>.inv</span>.app</span> <span class="fn">X✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mapCongr_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L241-L241">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapCongr_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapCongr_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f g : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapCongr">CategoryTheory.Over.mapCongr</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span>)</span>.hom</span>.app</span> <span class="fn">X✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mapFunctor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L247-L252">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapFunctor"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapFunctor</span></a></span><span class="decl_args">
<span class="fn">(T : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <a href="../../.././Mathlib/CategoryTheory/Category/Cat.html#CategoryTheory.Cat">CategoryTheory.Cat</a></span></div></div><p>The functor defined by the over categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapFunctor">CategoryTheory.Over.mapFunctor</a> <span class="fn">T</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">obj</span> := <span class="fn">fun (<span class="fn">X</span> : <span class="fn">T</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Cat.html#CategoryTheory.Cat.of">CategoryTheory.Cat.of</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span>)</span></span></span>,
    <span class="fn">map</span> := <span class="fn">fun {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">T</span>} =&gt; <span class="fn">CategoryTheory.Over.map</span></span>, <span class="fn">map_id</span> := <span class="fn">⋯</span>, <span class="fn">map_comp</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.mapFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.mapFunctor_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L248-L248">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapFunctor_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapFunctor_obj</span></a></span><span class="decl_args">
<span class="fn">(T : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapFunctor">CategoryTheory.Over.mapFunctor</a> <span class="fn">T</span>)</span>.obj</span> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Cat.html#CategoryTheory.Cat.of">CategoryTheory.Cat.of</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mapFunctor_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L248-L248">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapFunctor_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapFunctor_map</span></a></span><span class="decl_args">
<span class="fn">(T : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapFunctor">CategoryTheory.Over.mapFunctor</a> <span class="fn">T</span>)</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.forget_reflects_iso"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L256-L262">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget_reflects_iso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_reflects_iso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span>.ReflectsIsomorphisms</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.mkIdTerminal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L264-L266">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mkIdTerminal"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mkIdTerminal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/IsTerminal.html#CategoryTheory.Limits.IsTerminal">CategoryTheory.Limits.IsTerminal</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">X</span>)</span>)</span></span></div></div><p>The identity over <code>X</code> is terminal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Over.mkIdTerminal</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">CategoryTheory.CostructuredArrow.mkIdTerminal</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.mkIdTerminal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.forget_faithful"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L268-L268">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget_faithful"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_faithful</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span>.Faithful</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.epi_of_epi_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L271-L278">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.epi_of_epi_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">epi_of_epi_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[hk : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn"><span class="fn">k</span>.left</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn">k</span></span></div></div><p>If <code>k.left</code> is an epimorphism, then <code>k</code> is an epimorphism. In other words, <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">Over.forget</a> X</code> reflects
epimorphisms.
The converse does not hold without additional assumptions on the underlying category, see
<code>CategoryTheory.Over.epi_left_of_epi</code>.</p></div></div><div class="decl" id="CategoryTheory.Over.mono_of_mono_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L280-L288">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mono_of_mono_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mono_of_mono_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[hk : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn"><span class="fn">k</span>.left</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn">k</span></span></div></div><p>If <code>k.left</code> is a monomorphism, then <code>k</code> is a monomorphism. In other words, <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">Over.forget</a> X</code> reflects
monomorphisms.
The converse of <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mono_left_of_mono">CategoryTheory.Over.mono_left_of_mono</a></code>.</p><p>This lemma is not an instance, to avoid loops in type class inference.</p></div></div><div class="decl" id="CategoryTheory.Over.mono_left_of_mono"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L290-L302">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mono_left_of_mono"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mono_left_of_mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn">k</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn"><span class="fn">k</span>.left</span></span></div></div><p>If <code>k</code> is a monomorphism, then <code>k.left</code> is a monomorphism. In other words, <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">Over.forget</a> X</code> preserves
monomorphisms.
The converse of <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mono_of_mono_left">CategoryTheory.Over.mono_of_mono_left</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceForward"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L308-L312">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceForward"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn"><span class="fn">f</span>.left</span>)</span></span></div></div><p>Given f : Y ⟶ X, this is the obvious functor from (T/X)/f to T/Y</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Over.iteratedSliceForward" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceForward_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L309-L309">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceForward_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(κ : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceForward</span>.map</span> <span class="fn">κ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.left</span>.left</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceForward_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L309-L309">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceForward_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceForward</span>.obj</span> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn"><span class="fn"><span class="fn">α</span>.hom</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceBackward"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L314-L318">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceBackward"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn"><span class="fn">f</span>.left</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span>)</span></span></div></div><p>Given f : Y ⟶ X, this is the obvious functor from T/Y to (T/X)/f</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Over.iteratedSliceBackward" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceBackward_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L315-L315">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceBackward_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn"><span class="fn">f</span>.left</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceBackward</span>.obj</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn"><span class="fn">g</span>.hom</span> <span class="fn">⋯</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceBackward_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L315-L315">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceBackward_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn"><span class="fn">f</span>.left</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceBackward</span>.map</span> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn"><span class="fn">α</span>.left</span> <span class="fn">⋯</span>)</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceEquiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L320-L326">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceEquiv"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn"><span class="fn">f</span>.left</span></span></span></div></div><p>Given f : Y ⟶ X, we have an equivalence between (T/X)/f and T/Y</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Over.iteratedSliceEquiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceEquiv_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L321-L321">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceEquiv_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceEquiv</span>.counitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(fun (<span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn"><span class="fn">f</span>.left</span></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a>
        <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceBackward</span>.comp</span> <span class="fn"><span class="fn">f</span>.iteratedSliceForward</span>)</span>.obj</span> <span class="fn">g</span>)</span>.left</span>)</span> <span class="fn">⋯</span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceEquiv_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L321-L321">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceEquiv_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceEquiv</span>.unitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(fun (<span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a>
        <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a>
          <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span>)</span>)</span>.obj</span> <span class="fn">g</span>)</span>.left</span>.left</span>)</span> <span class="fn">⋯</span>)</span>
        <span class="fn">⋯</span></span>)</span>
    <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceEquiv_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L321-L321">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceEquiv_functor"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceEquiv</span>.functor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.iteratedSliceForward</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceEquiv_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L321-L321">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceEquiv_inverse"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceEquiv</span>.inverse</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.iteratedSliceBackward</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceForward_forget"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L328-L330">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceForward_forget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward_forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceForward</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn"><span class="fn">f</span>.left</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">f</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceBackward_forget_forget"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L332-L334">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.iteratedSliceBackward_forget_forget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward_forget_forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.iteratedSliceBackward</span>.comp</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">f</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn"><span class="fn">f</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.post"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L338-L343">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">X</span>)</span>)</span></span></div></div><p>A functor <code>F : T ⥤ D</code> induces a functor <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> X ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> (F.obj X)</code> in the obvious way.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Over.post" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.post_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L339-L339">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">F</span>)</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map</span> <span class="fn"><span class="fn">f</span>.left</span>)</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.post_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L339-L339">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">F</span>)</span>.obj</span> <span class="fn">Y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map</span> <span class="fn"><span class="fn">Y</span>.hom</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.post_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L345-L347">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post_comp"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">G</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">F</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">G</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.postComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L349-L353">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postComp"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">G</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">F</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">G</span>)</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">post</a> (F ⋙ G)</code> is isomorphic (actually equal) to <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">post</a> F ⋙ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">post</a> G</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postComp">CategoryTheory.Over.postComp</a> <span class="fn">F</span> <span class="fn">G</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(fun (<span class="fn">X_1</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">G</span>)</span>)</span>.obj</span> <span class="fn">X_1</span>)</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.postComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.postComp_hom_app_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L350-L350">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postComp_hom_app_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postComp_hom_app_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postComp">CategoryTheory.Over.postComp</a> <span class="fn">F</span> <span class="fn">G</span>)</span>.hom</span>.app</span> <span class="fn">X✝</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">G</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj</span> <span class="fn"><span class="fn">X✝</span>.left</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.postComp_inv_app_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L350-L350">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postComp_inv_app_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postComp_inv_app_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.postComp_inv_app_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L350-L350">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postComp_inv_app_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postComp_inv_app_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postComp">CategoryTheory.Over.postComp</a> <span class="fn">F</span> <span class="fn">G</span>)</span>.inv</span>.app</span> <span class="fn">X✝</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">G</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj</span> <span class="fn"><span class="fn">X✝</span>.left</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.postComp_hom_app_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L350-L350">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postComp_hom_app_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postComp_hom_app_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.postMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L355-L359">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postMap"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">F</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">(<span class="fn"><span class="fn">e</span>.app</span> <span class="fn">X</span>)</span>)</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">G</span></span></span></div></div><p>A natural transformation <code>F ⟶ G</code> induces a natural transformation on
<code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> X</code> up to <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">Under.map</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postMap">CategoryTheory.Over.postMap</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">app</span> := <span class="fn">fun (<span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn">(<span class="fn"><span class="fn">e</span>.app</span> <span class="fn"><span class="fn">Y</span>.left</span>)</span> <span class="fn">⋯</span></span></span>, <span class="fn">naturality</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.postMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.postMap_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L357-L357">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postMap_app"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postMap_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postMap">CategoryTheory.Over.postMap</a> <span class="fn">e</span>)</span>.app</span> <span class="fn">Y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn">(<span class="fn"><span class="fn">e</span>.app</span> <span class="fn"><span class="fn">Y</span>.left</span>)</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.postCongr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L361-L365">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postCongr"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postCongr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">F</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.hom</span>.app</span> <span class="fn">X</span>)</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">G</span></span></span></div></div><p>If <code>F</code> and <code>G</code> are naturally isomorphic, then <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">Over.post</a> F</code> and <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">Over.post</a> G</code> are also naturally
isomorphic up to <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">Over.map</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postCongr">CategoryTheory.Over.postCongr</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a> <span class="fn">(fun (<span class="fn">A</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a> <span class="fn">(<span class="fn"><span class="fn">e</span>.app</span> <span class="fn"><span class="fn">A</span>.left</span>)</span> <span class="fn">⋯</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.postCongr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.postCongr_inv_app_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L363-L363">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postCongr_inv_app_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postCongr_inv_app_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postCongr">CategoryTheory.Over.postCongr</a> <span class="fn">e</span>)</span>.inv</span>.app</span> <span class="fn">X✝</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inv</span>.app</span> <span class="fn"><span class="fn">X✝</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.postCongr_hom_app_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L363-L363">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postCongr_hom_app_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postCongr_hom_app_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postCongr">CategoryTheory.Over.postCongr</a> <span class="fn">e</span>)</span>.hom</span>.app</span> <span class="fn">X✝</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.hom</span>.app</span> <span class="fn"><span class="fn">X✝</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.postCongr_hom_app_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L363-L363">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postCongr_hom_app_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postCongr_hom_app_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.postCongr_inv_app_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L363-L363">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postCongr_inv_app_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postCongr_inv_app_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.instFaithfulObjPost"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L369-L372">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.instFaithfulObjPost"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">instFaithfulObjPost</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.Faithful</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">F</span>)</span>.Faithful</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.instFullObjPostOfFaithful"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L374-L378">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.instFullObjPostOfFaithful"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">instFullObjPostOfFaithful</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.Faithful</span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.Full</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">F</span>)</span>.Full</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.instEssSurjObjPostOfFull"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L380-L384">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.instEssSurjObjPostOfFull"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">instEssSurjObjPostOfFull</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.Full</span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.EssSurj</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">F</span>)</span>.EssSurj</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.instIsEquivalenceObjPost"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L386-L386">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.instIsEquivalenceObjPost"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">instIsEquivalenceObjPost</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.IsEquivalence</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">F</span>)</span>.IsEquivalence</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.postEquiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L388-L394">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postEquiv"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postEquiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">T</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.functor</span>.obj</span> <span class="fn">X</span>)</span></span></span></div></div><p>An equivalence of categories induces an equivalence on over categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Over.postEquiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.postEquiv_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L389-L389">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postEquiv_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postEquiv_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">T</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postEquiv">CategoryTheory.Over.postEquiv</a> <span class="fn">X</span> <span class="fn">F</span>)</span>.counitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(fun (<span class="fn">A</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.functor</span>.obj</span> <span class="fn">X</span>)</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.counitIso</span>.app</span> <span class="fn"><span class="fn">A</span>.left</span>)</span> <span class="fn">⋯</span></span>)</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.postEquiv_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L389-L389">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postEquiv_inverse"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postEquiv_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">T</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postEquiv">CategoryTheory.Over.postEquiv</a> <span class="fn">X</span> <span class="fn">F</span>)</span>.inverse</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn"><span class="fn">F</span>.inverse</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.unitIso</span>.inv</span>.app</span> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.postEquiv_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L389-L389">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postEquiv_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postEquiv_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">T</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postEquiv">CategoryTheory.Over.postEquiv</a> <span class="fn">X</span> <span class="fn">F</span>)</span>.unitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(fun (<span class="fn">A</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.unitIso</span>.app</span> <span class="fn"><span class="fn">A</span>.left</span>)</span> <span class="fn">⋯</span></span>)</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.postEquiv_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L389-L389">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postEquiv_functor"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">postEquiv_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">T</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.postEquiv">CategoryTheory.Over.postEquiv</a> <span class="fn">X</span> <span class="fn">F</span>)</span>.functor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn"><span class="fn">F</span>.functor</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.toOver"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L400-L404">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">F</span> <span class="fn">X</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span>)</span></span></div></div><p>Reinterpreting an <code>F</code>-costructured arrow <code>F.obj d ⟶ X</code> as an arrow over <code>X</code> induces a functor
<code>CostructuredArrow F X ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.pre">CategoryTheory.CostructuredArrow.pre</a> <span class="fn">F</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span> <span class="fn">X</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.CostructuredArrow.toOver" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.toOver_map_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L402-L402">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver_map_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_map_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span>)</span>.map</span> <span class="fn">f</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn"><span class="fn">f</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.toOver_map_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L402-L402">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver_map_right"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_map_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span>)</span>.map</span> <span class="fn">f</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">X✝</span>.right</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.toOver_obj_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L402-L402">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver_obj_right"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_obj_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">X✝</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">X✝</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.toOver_obj_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L402-L402">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver_obj_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_obj_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">X✝</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn"><span class="fn">X✝</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.toOver_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L402-L402">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">X✝</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">X✝</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.instFaithfulOverToOver"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L406-L407">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.instFaithfulOverToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">instFaithfulOverToOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.Faithful</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span>)</span>.Faithful</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.instFullOverToOver"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L409-L410">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.instFullOverToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">instFullOverToOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.Full</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span>)</span>.Full</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.instEssSurjOverToOver"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L412-L413">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.instEssSurjOverToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">instEssSurjOverToOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.EssSurj</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span>)</span>.EssSurj</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.isEquivalence_toOver"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L415-L418">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.isEquivalence_toOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">isEquivalence_toOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.IsEquivalence</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span>)</span>.IsEquivalence</span></div></div><p>An equivalence <code>F</code> induces an equivalence <code>CostructuredArrow F X ≌ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Under"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L422-L425">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under"><span class="name">CategoryTheory</span>.<span class="name">Under</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max u₁ v₁)</div></div><p>The under category has as objects arrows with domain <code>X</code> and as morphisms commutative
triangles.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.instCategoryUnder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L427-L427">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.instCategoryUnder"><span class="name">CategoryTheory</span>.<span class="name">instCategoryUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, max u₁ v₁}</a>            <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.instCategoryUnder">CategoryTheory.instCategoryUnder</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">CategoryTheory.commaCategory</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.inhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L430-L434">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.inhabited"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">inhabited</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">default</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.UnderMorphism.ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L440-L440">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.UnderMorphism.ext"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">UnderMorphism</span>.<span class="name">ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><span class="fn">U</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">f</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.right</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.under_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L446-L447">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.under_left"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">under_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">U</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">as</span> := <a href="../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a> }</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.id_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L449-L451">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.id_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">id_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">U</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">U</span>.right</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.comp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L453-L455">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.comp_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">comp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a b c : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">b</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.right</span> <span class="fn"><span class="fn">g</span>.right</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.w"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L457-L458">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.w"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">w</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A B : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">A</span>.hom</span> <span class="fn"><span class="fn">f</span>.right</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">B</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.w_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L457-L457">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">w_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A B : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">B</span>.right</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">A</span>.hom</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.right</span> <span class="fn">h</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">B</span>.hom</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L460-L463">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mk"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span></div></div><p>To give an object in the under category, it suffices to give an arrow with domain <code>X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mk">CategoryTheory.Under.mk</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mk">CategoryTheory.StructuredArrow.mk</a> <span class="fn">f</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.mk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.mk_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L461-L461">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mk_hom"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mk_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mk">CategoryTheory.Under.mk</a> <span class="fn">f</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mk_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L461-L461">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mk_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mk_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mk">CategoryTheory.Under.mk</a> <span class="fn">f</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Y</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.homMk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L465-L469">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.homMk"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">homMk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">U</span>.right</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">V</span>.right</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">U</span>.hom</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">V</span>.hom</span></span> := by aesop_cat)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">U</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span></div></div><p>To give a morphism in the under category, it suffices to give a morphism fitting in a
commutative triangle.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.homMk">CategoryTheory.Under.homMk</a> <span class="fn">f</span> <span class="fn">w</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.homMk">CategoryTheory.StructuredArrow.homMk</a> <span class="fn">f</span> <span class="fn">w</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.homMk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.homMk_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L467-L467">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.homMk_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">homMk_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">U</span>.right</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">V</span>.right</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">U</span>.hom</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">V</span>.hom</span></span> := by aesop_cat)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.homMk">CategoryTheory.Under.homMk</a> <span class="fn">f</span> <span class="fn">w</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.homMk_left_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L467-L467">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.homMk_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">homMk_left_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">U</span>.right</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">V</span>.right</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">U</span>.hom</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">V</span>.hom</span></span> := by aesop_cat)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.isoMk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L474-L479">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.isoMk"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">isoMk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><span class="fn"><span class="fn">f</span>.right</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.right</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.hom</span> <span class="fn"><span class="fn">hr</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.hom</span></span> := by aesop_cat)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">g</span></span></div></div><p>Construct an isomorphism in the over category given isomorphisms of the objects whose forward
direction gives a commutative triangle.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.isoMk">CategoryTheory.Under.isoMk</a> <span class="fn">hr</span> <span class="fn">hw</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.isoMk">CategoryTheory.StructuredArrow.isoMk</a> <span class="fn">hr</span> <span class="fn">hw</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.isoMk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.isoMk_hom_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L481-L484">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.isoMk_hom_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">isoMk_hom_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><span class="fn"><span class="fn">f</span>.right</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.right</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.hom</span> <span class="fn"><span class="fn">hr</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.hom</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.isoMk">CategoryTheory.Under.isoMk</a> <span class="fn">hr</span> <span class="fn">hw</span>)</span>.hom</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">hr</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.isoMk_inv_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L486-L489">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.isoMk_inv_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">isoMk_inv_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><span class="fn"><span class="fn">f</span>.right</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.right</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.hom</span> <span class="fn"><span class="fn">hr</span>.hom</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.hom</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.isoMk">CategoryTheory.Under.isoMk</a> <span class="fn">hr</span> <span class="fn">hw</span>)</span>.inv</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">hr</span>.inv</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.hom_right_inv_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L491-L494">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.hom_right_inv_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">hom_right_inv_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn"><span class="fn">e</span>.hom</span>.right</span> <span class="fn"><span class="fn"><span class="fn">e</span>.inv</span>.right</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">f</span>.right</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.hom_right_inv_right_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L491-L491">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.hom_right_inv_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">hom_right_inv_right_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">f</span>.right</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn"><span class="fn">e</span>.hom</span>.right</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn"><span class="fn">e</span>.inv</span>.right</span> <span class="fn">h</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.inv_right_hom_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L496-L499">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.inv_right_hom_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">inv_right_hom_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn"><span class="fn">e</span>.inv</span>.right</span> <span class="fn"><span class="fn"><span class="fn">e</span>.hom</span>.right</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">g</span>.right</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.inv_right_hom_right_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L496-L496">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.inv_right_hom_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">inv_right_hom_right_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">g</span>.right</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn"><span class="fn">e</span>.inv</span>.right</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn"><span class="fn">e</span>.hom</span>.right</span> <span class="fn">h</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.forget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L505-L507">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span>)</span> <span class="fn">T</span></span></div></div><p>The forgetful functor mapping an arrow to its domain.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.snd">CategoryTheory.Comma.snd</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.forget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.forget_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L511-L513">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">U</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.forget_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L515-L517">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">U</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.forgetCone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L519-L523">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forgetCone"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forgetCone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span></span></div></div><p>The natural cone over the forgetful functor <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> X ⥤ T</code> with cone point <code>X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forgetCone">CategoryTheory.Under.forgetCone</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn">X</span>, <span class="fn">π</span> := <span class="fn">{ <span class="fn">app</span> := <span class="fn">CategoryTheory.Comma.hom</span>, <span class="fn">naturality</span> := <span class="fn">⋯</span> }</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.forgetCone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.forgetCone_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L520-L520">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forgetCone_pt"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forgetCone_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forgetCone">CategoryTheory.Under.forgetCone</a> <span class="fn">X</span>)</span>.pt</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">X</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.forgetCone_π_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L520-L520">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forgetCone_π_app"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forgetCone_π_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forgetCone">CategoryTheory.Under.forgetCone</a> <span class="fn">X</span>)</span>.π</span>.app</span> <span class="fn">self</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">self</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L525-L527">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span>)</span></span></div></div><p>A morphism <code>X ⟶ Y</code> induces a functor <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> Y ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> X</code> in the obvious way.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.mapLeft">CategoryTheory.Comma.mapLeft</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span>
    <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans">CategoryTheory.Discrete.natTrans</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <a href="../../.././Init/Prelude.html#PUnit">PUnit.{1}</a></span>) =&gt; <span class="fn">f</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.map_obj_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L533-L535">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map_obj_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map_obj_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span>)</span>.obj</span> <span class="fn">U</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.map_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L537-L539">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span>)</span>.obj</span> <span class="fn">U</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn"><span class="fn">U</span>.hom</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.map_map_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L541-L543">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map_map_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map_map_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">U</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span>)</span>.map</span> <span class="fn">g</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mapIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L546-L548">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapIso"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span></span></div></div><p>If <code>f</code> is an isomorphism, <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">map</a> f</code> is an equivalence of categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapIso">CategoryTheory.Under.mapIso</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.mapLeftIso">CategoryTheory.Comma.mapLeftIso</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span>
    <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso">CategoryTheory.Discrete.natIso</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <a href="../../.././Init/Prelude.html#PUnit">PUnit.{1}</a></span>) =&gt; <span class="fn"><span class="fn">f</span>.symm</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.mapIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.mapIso_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L550-L550">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapIso_functor"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapIso_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapIso">CategoryTheory.Under.mapIso</a> <span class="fn">f</span>)</span>.functor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn"><span class="fn">f</span>.hom</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mapIso_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L551-L551">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapIso_inverse"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapIso_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapIso">CategoryTheory.Under.mapIso</a> <span class="fn">f</span>)</span>.inverse</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn"><span class="fn">f</span>.inv</span></span></span></div></div></div></div><div class="mod_doc"><p>This section proves various equalities between functors that
demonstrate, for instance, that under categories assemble into a
functor <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapFunctor">mapFunctor</a> : Tᵒᵖ ⥤ Cat</code>.</p></div><div class="decl" id="CategoryTheory.Under.mapId_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L560-L569">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapId_eq"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapId_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">Y</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span>)</span></span></span></div></div><p>Mapping by the identity morphism is just the identity functor.</p></div></div><div class="decl" id="CategoryTheory.Under.mapId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L571-L573">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapId"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapId</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">Y</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span>)</span></span></span></div></div><p>Mapping by the identity morphism is just the identity functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapId">CategoryTheory.Under.mapId</a> <span class="fn">Y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso">CategoryTheory.eqToIso</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.mapId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.mapId_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L572-L572">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapId_hom"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapId_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapId">CategoryTheory.Under.mapId</a> <span class="fn">Y</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mapId_inv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L572-L572">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapId_inv"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapId_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapId">CategoryTheory.Under.mapId</a> <span class="fn">Y</span>)</span>.inv</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mapForget_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L575-L580">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapForget_eq"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapForget_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">Y</span></span></span></div></div><p>Mapping by <code>f</code> and then forgetting is the same as forgetting.</p></div></div><div class="decl" id="CategoryTheory.Under.mapForget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L582-L584">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapForget"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapForget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">Y</span></span></span></div></div><p>The natural isomorphism arising from <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapForget_eq">mapForget_eq</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapForget">CategoryTheory.Under.mapForget</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso">CategoryTheory.eqToIso</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.mapForget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.eqToHom_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L586-L589">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.eqToHom_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">eqToHom_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U V : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">U</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">V</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">e</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mapComp_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L591-L598">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapComp_eq"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapComp_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">g</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span>)</span></span></span></div></div><p>Mapping by the composite morphism <code>f ≫ g</code> is the same as mapping by <code>f</code> then by <code>g</code>.</p></div></div><div class="decl" id="CategoryTheory.Under.mapComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L600-L603">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapComp"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">g</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span>)</span></span></span></div></div><p>The natural isomorphism arising from <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mapComp_eq">mapComp_eq</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapComp">CategoryTheory.Under.mapComp</a> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso">CategoryTheory.eqToIso</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.mapComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.mapComp_inv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L601-L601">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapComp_inv"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapComp_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapComp">CategoryTheory.Under.mapComp</a> <span class="fn">f</span> <span class="fn">g</span>)</span>.inv</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mapComp_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L601-L601">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapComp_hom"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapComp_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapComp">CategoryTheory.Under.mapComp</a> <span class="fn">f</span> <span class="fn">g</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mapCongr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L605-L609">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapCongr"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapCongr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f g : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">g</span></span></span></div></div><p>If <code>f = g</code>, then <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">map</a> f</code> is naturally isomorphic to <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">map</a> g</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapCongr">CategoryTheory.Under.mapCongr</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a> <span class="fn">(fun (<span class="fn">A</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso">CategoryTheory.eqToIso</a> <span class="fn">⋯</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.mapCongr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.mapCongr_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L606-L606">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapCongr_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapCongr_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f g : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapCongr">CategoryTheory.Under.mapCongr</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span>)</span>.hom</span>.app</span> <span class="fn">X✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mapCongr_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L606-L606">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapCongr_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapCongr_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f g : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapCongr">CategoryTheory.Under.mapCongr</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span>)</span>.inv</span>.app</span> <span class="fn">X✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mapFunctor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L612-L617">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapFunctor"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapFunctor</span></a></span><span class="decl_args">
<span class="fn">(T : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">T</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <a href="../../.././Mathlib/CategoryTheory/Category/Cat.html#CategoryTheory.Cat">CategoryTheory.Cat</a></span></div></div><p>The functor defined by the under categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Under.mapFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.mapFunctor_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L613-L613">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapFunctor_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapFunctor_obj</span></a></span><span class="decl_args">
<span class="fn">(T : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapFunctor">CategoryTheory.Under.mapFunctor</a> <span class="fn">T</span>)</span>.obj</span> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Cat.html#CategoryTheory.Cat.of">CategoryTheory.Cat.of</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mapFunctor_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L613-L613">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapFunctor_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapFunctor_map</span></a></span><span class="decl_args">
<span class="fn">(T : <a href="../../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><span class="fn">T</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mapFunctor">CategoryTheory.Under.mapFunctor</a> <span class="fn">T</span>)</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn"><span class="fn">f</span>.unop</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.forget_reflects_iso"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L621-L627">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget_reflects_iso"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_reflects_iso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span>.ReflectsIsomorphisms</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.mkIdInitial"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L629-L631">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mkIdInitial"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mkIdInitial</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/IsTerminal.html#CategoryTheory.Limits.IsInitial">CategoryTheory.Limits.IsInitial</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mk">CategoryTheory.Under.mk</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">X</span>)</span>)</span></span></div></div><p>The identity under <code>X</code> is initial.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Under.mkIdInitial</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">CategoryTheory.StructuredArrow.mkIdInitial</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.mkIdInitial" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.forget_faithful"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L633-L633">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget_faithful"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_faithful</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span>.Faithful</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.mono_of_mono_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L636-L642">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mono_of_mono_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mono_of_mono_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[hk : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn"><span class="fn">k</span>.right</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn">k</span></span></div></div><p>If <code>k.right</code> is a monomorphism, then <code>k</code> is a monomorphism. In other words, <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">Under.forget</a> X</code>
reflects epimorphisms.
The converse does not hold without additional assumptions on the underlying category, see
<code>CategoryTheory.Under.mono_right_of_mono</code>.</p></div></div><div class="decl" id="CategoryTheory.Under.epi_of_epi_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L644-L652">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.epi_of_epi_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">epi_of_epi_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[hk : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn"><span class="fn">k</span>.right</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn">k</span></span></div></div><p>If <code>k.right</code> is an epimorphism, then <code>k</code> is an epimorphism. In other words, <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">Under.forget</a> X</code>
reflects epimorphisms.
The converse of <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.epi_right_of_epi">CategoryTheory.Under.epi_right_of_epi</a></code>.</p><p>This lemma is not an instance, to avoid loops in type class inference.</p></div></div><div class="decl" id="CategoryTheory.Under.epi_right_of_epi"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L654-L665">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.epi_right_of_epi"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">epi_right_of_epi</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn">k</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn"><span class="fn">k</span>.right</span></span></div></div><p>If <code>k</code> is an epimorphism, then <code>k.right</code> is an epimorphism. In other words, <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">Under.forget</a> X</code>
preserves epimorphisms.
The converse of <code>CategoryTheory.under.<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.epi_of_epi_right">epi_of_epi_right</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.post"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L667-L672">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">X</span>)</span>)</span></span></div></div><p>A functor <code>F : T ⥤ D</code> induces a functor <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> X ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> (F.obj X)</code> in the obvious way.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Under.post" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.post_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L668-L668">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">F</span>)</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.homMk">CategoryTheory.Under.homMk</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map</span> <span class="fn"><span class="fn">f</span>.right</span>)</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.post_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L668-L668">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">F</span>)</span>.obj</span> <span class="fn">Y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mk">CategoryTheory.Under.mk</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map</span> <span class="fn"><span class="fn">Y</span>.hom</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.post_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L674-L676">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post_comp"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">G</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">F</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">G</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.postComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L678-L682">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postComp"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">G</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">F</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">G</span>)</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">post</a> (F ⋙ G)</code> is isomorphic (actually equal) to <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">post</a> F ⋙ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.post">post</a> G</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postComp">CategoryTheory.Under.postComp</a> <span class="fn">F</span> <span class="fn">G</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(fun (<span class="fn">X_1</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">G</span>)</span>)</span>.obj</span> <span class="fn">X_1</span>)</span></span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.postComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.postComp_inv_app_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L679-L679">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postComp_inv_app_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postComp_inv_app_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postComp">CategoryTheory.Under.postComp</a> <span class="fn">F</span> <span class="fn">G</span>)</span>.inv</span>.app</span> <span class="fn">X✝</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">G</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj</span> <span class="fn"><span class="fn">X✝</span>.right</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.postComp_hom_app_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L679-L679">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postComp_hom_app_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postComp_hom_app_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postComp">CategoryTheory.Under.postComp</a> <span class="fn">F</span> <span class="fn">G</span>)</span>.hom</span>.app</span> <span class="fn">X✝</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">G</span>.obj</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj</span> <span class="fn"><span class="fn">X✝</span>.right</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.postComp_hom_app_left_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L679-L679">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postComp_hom_app_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postComp_hom_app_left_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.postComp_inv_app_left_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L679-L679">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postComp_inv_app_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postComp_inv_app_left_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{u_2, u_1}</a>      <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.postMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L684-L688">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postMap"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">F</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">G</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">(<span class="fn"><span class="fn">e</span>.app</span> <span class="fn">X</span>)</span>)</span></span></span></div></div><p>A natural transformation <code>F ⟶ G</code> induces a natural transformation on
<code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> X</code> up to <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">Under.map</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postMap">CategoryTheory.Under.postMap</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">app</span> := <span class="fn">fun (<span class="fn">Y</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.homMk">CategoryTheory.Under.homMk</a> <span class="fn">(<span class="fn"><span class="fn">e</span>.app</span> <span class="fn"><span class="fn">Y</span>.right</span>)</span> <span class="fn">⋯</span></span></span>, <span class="fn">naturality</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.postMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.postMap_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L686-L686">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postMap_app"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postMap_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postMap">CategoryTheory.Under.postMap</a> <span class="fn">e</span>)</span>.app</span> <span class="fn">Y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.homMk">CategoryTheory.Under.homMk</a> <span class="fn">(<span class="fn"><span class="fn">e</span>.app</span> <span class="fn"><span class="fn">Y</span>.right</span>)</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.postCongr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L690-L694">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postCongr"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postCongr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">F</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">G</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.hom</span>.app</span> <span class="fn">X</span>)</span>)</span></span></span></div></div><p>If <code>F</code> and <code>G</code> are naturally isomorphic, then <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">Under.post</a> F</code> and <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">Under.post</a> G</code> are also
naturally isomorphic up to <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">Under.map</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postCongr">CategoryTheory.Under.postCongr</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a> <span class="fn">(fun (<span class="fn">A</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.isoMk">CategoryTheory.Under.isoMk</a> <span class="fn">(<span class="fn"><span class="fn">e</span>.app</span> <span class="fn"><span class="fn">A</span>.right</span>)</span> <span class="fn">⋯</span></span>)</span>
    <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.postCongr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.postCongr_hom_app_left_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L692-L692">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postCongr_hom_app_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postCongr_hom_app_left_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.postCongr_hom_app_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L692-L692">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postCongr_hom_app_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postCongr_hom_app_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postCongr">CategoryTheory.Under.postCongr</a> <span class="fn">e</span>)</span>.hom</span>.app</span> <span class="fn">X✝</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.hom</span>.app</span> <span class="fn"><span class="fn">X✝</span>.right</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.postCongr_inv_app_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L692-L692">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postCongr_inv_app_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postCongr_inv_app_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postCongr">CategoryTheory.Under.postCongr</a> <span class="fn">e</span>)</span>.inv</span>.app</span> <span class="fn">X✝</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.inv</span>.app</span> <span class="fn"><span class="fn">X✝</span>.right</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.postCongr_inv_app_left_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L692-L692">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postCongr_inv_app_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postCongr_inv_app_left_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F G : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">F</span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.instFaithfulObjPost"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L698-L701">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.instFaithfulObjPost"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">instFaithfulObjPost</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.Faithful</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">F</span>)</span>.Faithful</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.instFullObjPostOfFaithful"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L703-L708">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.instFullObjPostOfFaithful"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">instFullObjPostOfFaithful</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.Faithful</span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.Full</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">F</span>)</span>.Full</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.instEssSurjObjPostOfFull"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L710-L714">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.instEssSurjObjPostOfFull"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">instEssSurjObjPostOfFull</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.Full</span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.EssSurj</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">F</span>)</span>.EssSurj</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.instIsEquivalenceObjPost"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L716-L716">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.instIsEquivalenceObjPost"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">instIsEquivalenceObjPost</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.IsEquivalence</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">F</span>)</span>.IsEquivalence</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.postEquiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L718-L724">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postEquiv"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postEquiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">T</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.functor</span>.obj</span> <span class="fn">X</span>)</span></span></span></div></div><p>An equivalence of categories induces an equivalence on under categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Under.postEquiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.postEquiv_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L719-L719">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postEquiv_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postEquiv_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">T</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postEquiv">CategoryTheory.Under.postEquiv</a> <span class="fn">X</span> <span class="fn">F</span>)</span>.counitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(fun (<span class="fn">A</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.functor</span>.obj</span> <span class="fn">X</span>)</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.isoMk">CategoryTheory.Under.isoMk</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.counitIso</span>.app</span> <span class="fn"><span class="fn">A</span>.right</span>)</span> <span class="fn">⋯</span></span>)</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.postEquiv_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L719-L719">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postEquiv_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postEquiv_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">T</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postEquiv">CategoryTheory.Under.postEquiv</a> <span class="fn">X</span> <span class="fn">F</span>)</span>.unitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a>
    <span class="fn">(fun (<span class="fn">A</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.isoMk">CategoryTheory.Under.isoMk</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.unitIso</span>.app</span> <span class="fn"><span class="fn">A</span>.right</span>)</span> <span class="fn">⋯</span></span>)</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.postEquiv_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L719-L719">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postEquiv_inverse"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postEquiv_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">T</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postEquiv">CategoryTheory.Under.postEquiv</a> <span class="fn">X</span> <span class="fn">F</span>)</span>.inverse</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn"><span class="fn">F</span>.inverse</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.unitIso</span>.hom</span>.app</span> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.postEquiv_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L719-L719">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postEquiv_functor"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">postEquiv_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><span class="fn">T</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.postEquiv">CategoryTheory.Under.postEquiv</a> <span class="fn">X</span> <span class="fn">F</span>)</span>.functor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn"><span class="fn">F</span>.functor</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.toUnder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L732-L736">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">F</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span>)</span></span></div></div><p>Reinterpreting an <code>F</code>-structured arrow <code>X ⟶ F.obj d</code> as an arrow under <code>X</code> induces a functor
<code>StructuredArrow X F ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.pre">CategoryTheory.StructuredArrow.pre</a> <span class="fn">X</span> <span class="fn">F</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.StructuredArrow.toUnder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.toUnder_map_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L734-L734">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder_map_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_map_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span>)</span>.map</span> <span class="fn">f</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn"><span class="fn">f</span>.right</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.toUnder_obj_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L734-L734">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder_obj_left"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_obj_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span>)</span>.obj</span> <span class="fn">X✝</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">X✝</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.toUnder_obj_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L734-L734">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder_obj_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_obj_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span>)</span>.obj</span> <span class="fn">X✝</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn"><span class="fn">X✝</span>.right</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.toUnder_map_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L734-L734">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder_map_left"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_map_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span>)</span>.map</span> <span class="fn">f</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">X✝</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.toUnder_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L734-L734">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span>)</span>.obj</span> <span class="fn">X✝</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">X✝</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.instFaithfulUnderToUnder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L738-L739">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.instFaithfulUnderToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">instFaithfulUnderToUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.Faithful</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span>)</span>.Faithful</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.instFullUnderToUnder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L741-L742">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.instFullUnderToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">instFullUnderToUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.Full</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span>)</span>.Full</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.instEssSurjUnderToUnder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L744-L745">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.instEssSurjUnderToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">instEssSurjUnderToUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.EssSurj</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span>)</span>.EssSurj</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.isEquivalence_toUnder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L747-L750">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.isEquivalence_toUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">isEquivalence_toUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.IsEquivalence</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span>)</span>.IsEquivalence</span></div></div><p>An equivalence <code>F</code> induces an equivalence <code>StructuredArrow X F ≌ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.toOver"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L758-L764">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toOver"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">Z</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span>)</span></span></div></div><p>Given <code>X : T</code>, to upgrade a functor <code>F : S ⥤ T</code> to a functor <code>S ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> X</code>, it suffices to
provide maps <code>F.obj Y ⟶ X</code> for all <code>Y</code> making the obvious triangles involving all <code>F.<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">map</a> g</code>
commute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.toOver</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.toCostructuredArrow</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.toOver" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.toOver_obj_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L761-L761">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toOver_obj_left"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver_obj_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">Z</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">S</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.toOver</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span>)</span>.obj</span> <span class="fn">Y</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.toOver_map_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L761-L761">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toOver_map_left"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver_map_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">Z</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn">S</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.toOver</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span>)</span>.map</span> <span class="fn">g</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.toOverCompForget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L766-L770">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toOverCompForget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOverCompForget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">Z</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.toOver</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">⋯</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span></div></div><p>Upgrading a functor <code>S ⥤ T</code> to a functor <code>S ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> X</code> and composing with the forgetful functor
<code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">Over</a> X ⥤ T</code> recovers the original functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.toOverCompForget</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.toOver</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">⋯</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.toOverCompForget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.toOver_comp_forget"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L772-L775">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toOver_comp_forget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver_comp_forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">Z</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.toOver</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">⋯</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">F</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.toUnder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L777-L783">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toUnder"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn">f</span> <span class="fn">Y</span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span>)</span></span></div></div><p>Given <code>X : T</code>, to upgrade a functor <code>F : S ⥤ T</code> to a functor <code>S ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> X</code>, it suffices to
provide maps <code>X ⟶ F.obj Y</code> for all <code>Y</code> making the obvious triangles involving all <code>F.<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.map">map</a> g</code>
commute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.toUnder</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.toStructuredArrow</span> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span>)</span> <span class="fn">f</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.toUnder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.toUnder_map_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L780-L780">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toUnder_map_right"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder_map_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn">f</span> <span class="fn">Y</span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn">S</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.toUnder</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span>)</span>.map</span> <span class="fn">g</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.toUnder_obj_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L780-L780">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toUnder_obj_right"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder_obj_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn">f</span> <span class="fn">Y</span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">S</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.toUnder</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span>)</span>.obj</span> <span class="fn">Y</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.toUnderCompForget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L785-L789">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toUnderCompForget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnderCompForget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn">f</span> <span class="fn">Y</span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.toUnder</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">⋯</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></span></div></div><p>Upgrading a functor <code>S ⥤ T</code> to a functor <code>S ⥤ <a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> X</code> and composing with the forgetful functor
<code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">Under</a> X ⥤ T</code> recovers the original functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.toUnderCompForget</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.toUnder</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">⋯</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Functor.toUnderCompForget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.toUnder_comp_forget"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L791-L794">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Functor.toUnder_comp_forget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder_comp_forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn">f</span> <span class="fn">Y</span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.map</span> <span class="fn">g</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.toUnder</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">⋯</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">F</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L800-L808">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.proj">CategoryTheory.StructuredArrow.proj</a> <span class="fn">Y</span> <span class="fn">F</span>)</span>)</span>
  <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">Y</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span>)</span></span></div></div><p>A functor from the structured arrow category on the projection functor for any structured
arrow category.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L802-L802">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">functor_obj_right_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.proj">CategoryTheory.StructuredArrow.proj</a> <span class="fn">Y</span> <span class="fn">F</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor">CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.right</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">Y✝</span>.right</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L802-L802">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">functor_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.proj">CategoryTheory.StructuredArrow.proj</a> <span class="fn">Y</span> <span class="fn">F</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor">CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">Y✝</span>.right</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_right_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L802-L802">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_right_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">functor_map_right_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.proj">CategoryTheory.StructuredArrow.proj</a> <span class="fn">Y</span> <span class="fn">F</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor">CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.map</span> <span class="fn">g</span>)</span>.right</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">g</span>.right</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L802-L802">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">functor_obj_right_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.proj">CategoryTheory.StructuredArrow.proj</a> <span class="fn">Y</span> <span class="fn">F</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor">CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.right</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">Y✝</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_left_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L802-L802">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">functor_map_left_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.proj">CategoryTheory.StructuredArrow.proj</a> <span class="fn">Y</span> <span class="fn">F</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_left_as"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L802-L802">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_left_as"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">functor_obj_right_left_as</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.proj">CategoryTheory.StructuredArrow.proj</a> <span class="fn">Y</span> <span class="fn">F</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor">CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.right</span>.left</span>.as</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_right_left_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L802-L802">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_right_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">functor_map_right_left_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.proj">CategoryTheory.StructuredArrow.proj</a> <span class="fn">Y</span> <span class="fn">F</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_left_as"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L802-L802">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_left_as"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">functor_obj_left_as</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.proj">CategoryTheory.StructuredArrow.proj</a> <span class="fn">Y</span> <span class="fn">F</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor">CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.left</span>.as</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L810-L817">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">Y</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span>)</span>
  <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.proj">CategoryTheory.StructuredArrow.proj</a> <span class="fn">Y</span> <span class="fn">F</span>)</span>)</span></span></div></div><p>The inverse functor of <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor">ofStructuredArrowProjEquivalence.functor</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_right_left_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L811-L811">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_right_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">inverse_map_right_left_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">Y</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L811-L811">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">Y</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse">CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">Y✝</span>.right</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_left_as"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L811-L811">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_left_as"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_right_left_as</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">Y</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse">CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.right</span>.left</span>.as</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L811-L811">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_right_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">Y</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse">CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.right</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">Y✝</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_right_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L811-L811">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_right_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">inverse_map_right_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">Y</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse">CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.map</span> <span class="fn">g</span>)</span>.right</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">g</span>.right</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_left_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L811-L811">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">inverse_map_left_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">Y</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L811-L811">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_right_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">Y</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse">CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.right</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">Y✝</span>.right</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_left_as"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L811-L811">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_left_as"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_left_as</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">Y</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse">CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.left</span>.as</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L819-L826">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofStructuredArrowProjEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.proj">CategoryTheory.StructuredArrow.proj</a> <span class="fn">Y</span> <span class="fn">F</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">Y</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span></span></span></div></div><p>Characterization of the structured arrow category on the projection functor of any
structured arrow category.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofDiagEquivalence.functor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L828-L836">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span>)</span>
  <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn"><span class="fn">X</span>.2</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn"><span class="fn">X</span>.1</span>)</span>)</span></span></div></div><p>The canonical functor from the structured arrow category on the diagonal functor
<code>T ⥤ T × T</code> to the structured arrow category on <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">Under.forget</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.StructuredArrow.ofDiagEquivalence.functor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L830-L830">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor">CategoryTheory.StructuredArrow.ofDiagEquivalence.functor</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">Y</span>.hom</span>.2</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_right_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L830-L830">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_right_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_right_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor">CategoryTheory.StructuredArrow.ofDiagEquivalence.functor</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span>)</span>.right</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">Y</span>.hom</span>.1</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_map_right_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L830-L830">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_map_right_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_map_right_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor">CategoryTheory.StructuredArrow.ofDiagEquivalence.functor</a> <span class="fn">X</span>)</span>.map</span> <span class="fn">g</span>)</span>.right</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_right_left_as"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L830-L830">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_right_left_as"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_right_left_as</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor">CategoryTheory.StructuredArrow.ofDiagEquivalence.functor</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span>)</span>.right</span>.left</span>.as</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_right_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L830-L830">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_right_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_right_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor">CategoryTheory.StructuredArrow.ofDiagEquivalence.functor</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span>)</span>.right</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">Y</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_map_right_left_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L830-L830">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_map_right_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_map_right_left_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_left_as"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L830-L830">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_left_as"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_left_as</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor">CategoryTheory.StructuredArrow.ofDiagEquivalence.functor</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span>)</span>.left</span>.as</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_map_left_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L830-L830">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_map_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_map_left_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L838-L843">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn"><span class="fn">X</span>.2</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn"><span class="fn">X</span>.1</span>)</span>)</span>
  <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span>)</span></span></div></div><p>The inverse functor of <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor">ofDiagEquivalence.functor</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L839-L839">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn"><span class="fn">X</span>.2</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn"><span class="fn">X</span>.1</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse">CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">Y</span>.right</span>.hom</span>, <span class="fn"><span class="fn">Y</span>.hom</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_obj_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L839-L839">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_obj_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_obj_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn"><span class="fn">X</span>.2</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn"><span class="fn">X</span>.1</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse">CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">Y</span>.right</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_map_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L839-L839">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_map_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_map_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn"><span class="fn">X</span>.2</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn"><span class="fn">X</span>.1</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse">CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse</a> <span class="fn">X</span>)</span>.map</span> <span class="fn">g</span>)</span>.right</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">g</span>.right</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_map_left_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L839-L839">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_map_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_map_left_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn"><span class="fn">X</span>.2</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn"><span class="fn">X</span>.1</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_obj_left_as"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L839-L839">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_obj_left_as"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_obj_left_as</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn"><span class="fn">X</span>.2</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn"><span class="fn">X</span>.1</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse">CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span>)</span>.left</span>.as</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofDiagEquivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L845-L851">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn"><span class="fn">X</span>.2</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn"><span class="fn">X</span>.1</span>)</span></span></span></div></div><p>Characterization of the structured arrow category on the diagonal functor <code>T ⥤ T × T</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.StructuredArrow.ofDiagEquivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.ofDiagEquivalence'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L853-L859">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence'"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">ofDiagEquivalence'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn"><span class="fn">X</span>.1</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn"><span class="fn">X</span>.2</span>)</span></span></span></div></div><p>A version of <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence">StructuredArrow.ofDiagEquivalence</a></code> with the roles of the first and second
projection swapped.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.StructuredArrow.ofDiagEquivalence'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L865-L873">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.proj">CategoryTheory.CostructuredArrow.proj</a> <span class="fn">F</span> <span class="fn">Y</span>)</span> <span class="fn">X</span>)</span>
  <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span> <span class="fn">Y</span>)</span></span></div></div><p>A functor from the costructured arrow category on the projection functor for any costructured
arrow category.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L867-L867">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">functor_obj_left_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.proj">CategoryTheory.CostructuredArrow.proj</a> <span class="fn">F</span> <span class="fn">Y</span>)</span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor">CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.left</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">Y✝</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_map_left_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L867-L867">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_map_left_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">functor_map_left_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.proj">CategoryTheory.CostructuredArrow.proj</a> <span class="fn">F</span> <span class="fn">Y</span>)</span> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L867-L867">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">functor_obj_left_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.proj">CategoryTheory.CostructuredArrow.proj</a> <span class="fn">F</span> <span class="fn">Y</span>)</span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor">CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.left</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">Y✝</span>.left</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L867-L867">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">functor_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.proj">CategoryTheory.CostructuredArrow.proj</a> <span class="fn">F</span> <span class="fn">Y</span>)</span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor">CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">Y✝</span>.left</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_map_left_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L867-L867">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_map_left_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">functor_map_left_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.proj">CategoryTheory.CostructuredArrow.proj</a> <span class="fn">F</span> <span class="fn">Y</span>)</span> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor">CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.map</span> <span class="fn">g</span>)</span>.left</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">g</span>.left</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_right_as"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L867-L867">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_right_as"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">functor_obj_left_right_as</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.proj">CategoryTheory.CostructuredArrow.proj</a> <span class="fn">F</span> <span class="fn">Y</span>)</span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor">CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.left</span>.right</span>.as</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_right_as"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L867-L867">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_right_as"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">functor_obj_right_as</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.proj">CategoryTheory.CostructuredArrow.proj</a> <span class="fn">F</span> <span class="fn">Y</span>)</span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor">CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.right</span>.as</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_map_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L867-L867">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_map_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">functor_map_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.proj">CategoryTheory.CostructuredArrow.proj</a> <span class="fn">F</span> <span class="fn">Y</span>)</span> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L875-L882">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span> <span class="fn">Y</span>)</span>
  <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.proj">CategoryTheory.CostructuredArrow.proj</a> <span class="fn">F</span> <span class="fn">Y</span>)</span> <span class="fn">X</span>)</span></span></div></div><p>The inverse functor of <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor">ofCostructuredArrowProjEquivalence.functor</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_map_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L876-L876">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_map_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">inverse_map_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L876-L876">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse">CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">Y✝</span>.left</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_map_left_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L876-L876">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_map_left_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">inverse_map_left_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse">CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.map</span> <span class="fn">g</span>)</span>.left</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">g</span>.left</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_right_as"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L876-L876">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_right_as"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_right_as</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse">CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.right</span>.as</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_right_as"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L876-L876">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_right_as"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_left_right_as</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse">CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.left</span>.right</span>.as</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L876-L876">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_left_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse">CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.left</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">Y✝</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_map_left_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L876-L876">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_map_left_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">inverse_map_left_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L876-L876">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span>.<span class="name">inverse_obj_left_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse">CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse</a> <span class="fn">F</span> <span class="fn">Y</span> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y✝</span>)</span>.left</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">Y✝</span>.left</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L884-L892">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofCostructuredArrowProjEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.proj">CategoryTheory.CostructuredArrow.proj</a> <span class="fn">F</span> <span class="fn">Y</span>)</span> <span class="fn">X</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">F</span>)</span> <span class="fn">Y</span></span></span></div></div><p>Characterization of the costructured arrow category on the projection functor of any
costructured arrow category.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L894-L903">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span> <span class="fn">X</span>)</span>
  <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn"><span class="fn">X</span>.1</span>)</span> <span class="fn"><span class="fn">X</span>.2</span>)</span></span></div></div><p>The canonical functor from the costructured arrow category on the diagonal functor
<code>T ⥤ T × T</code> to the costructured arrow category on <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.forget">Under.forget</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_map_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L896-L896">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_map_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_map_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L896-L896">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor">CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">Y</span>.hom</span>.2</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_map_left_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L896-L896">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_map_left_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_map_left_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor">CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor</a> <span class="fn">X</span>)</span>.map</span> <span class="fn">g</span>)</span>.left</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_left_right_as"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L896-L896">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_left_right_as"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_left_right_as</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor">CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span>)</span>.left</span>.right</span>.as</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_map_left_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L896-L896">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_map_left_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_map_left_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_left_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L896-L896">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_left_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_left_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor">CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span>)</span>.left</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">Y</span>.hom</span>.1</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_left_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L896-L896">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_left_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_left_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor">CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span>)</span>.left</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">Y</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_right_as"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L896-L896">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_right_as"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">functor_obj_right_as</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor">CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span>)</span>.right</span>.as</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L905-L910">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn"><span class="fn">X</span>.1</span>)</span> <span class="fn"><span class="fn">X</span>.2</span>)</span>
  <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span> <span class="fn">X</span>)</span></span></div></div><p>The inverse functor of <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor">ofDiagEquivalence.functor</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_map_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L906-L906">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_map_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_map_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn"><span class="fn">X</span>.1</span>)</span> <span class="fn"><span class="fn">X</span>.2</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse">CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse</a> <span class="fn">X</span>)</span>.map</span> <span class="fn">g</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">g</span>.left</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_obj_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L906-L906">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_obj_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_obj_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn"><span class="fn">X</span>.1</span>)</span> <span class="fn"><span class="fn">X</span>.2</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse">CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span>)</span>.left</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">Y</span>.left</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_map_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L906-L906">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_map_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_map_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X✝ Y✝ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn"><span class="fn">X</span>.1</span>)</span> <span class="fn"><span class="fn">X</span>.2</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">X✝</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L906-L906">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn"><span class="fn">X</span>.1</span>)</span> <span class="fn"><span class="fn">X</span>.2</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse">CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span>)</span>.hom</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">Y</span>.left</span>.hom</span>, <span class="fn"><span class="fn">Y</span>.hom</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_obj_right_as"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L906-L906">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_obj_right_as"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span>.<span class="name">inverse_obj_right_as</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn"><span class="fn">X</span>.1</span>)</span> <span class="fn"><span class="fn">X</span>.2</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse">CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span>)</span>.right</span>.as</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofDiagEquivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L912-L918">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span> <span class="fn">X</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn"><span class="fn">X</span>.1</span>)</span> <span class="fn"><span class="fn">X</span>.2</span></span></span></div></div><p>Characterization of the costructured arrow category on the diagonal functor <code>T ⥤ T × T</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.CostructuredArrow.ofDiagEquivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.ofDiagEquivalence'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L920-L926">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence'"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">ofDiagEquivalence'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">T</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">T</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Products/Basic.html#CategoryTheory.Functor.diag">CategoryTheory.Functor.diag</a> <span class="fn">T</span>)</span> <span class="fn">X</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn"><span class="fn">X</span>.2</span>)</span> <span class="fn"><span class="fn">X</span>.1</span></span></span></div></div><p>A version of <code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence">CostructuredArrow.ofDiagEquivalence</a></code> with the roles of the first and second
projection swapped.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.CostructuredArrow.ofDiagEquivalence'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.opToOpUnder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L936-L940">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opToOpUnder"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opToOpUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span></div></div><p>The canonical functor by reversing structure arrows.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Over.opToOpUnder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.opToOpUnder_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L937-L937">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opToOpUnder_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opToOpUnder_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opToOpUnder">CategoryTheory.Over.opToOpUnder</a> <span class="fn">X</span>)</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.homMk">CategoryTheory.Under.homMk</a> <span class="fn"><span class="fn"><span class="fn">f</span>.left</span>.unop</span> <span class="fn">⋯</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.opToOpUnder_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L937-L937">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opToOpUnder_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opToOpUnder_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opToOpUnder">CategoryTheory.Over.opToOpUnder</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mk">CategoryTheory.Under.mk</a> <span class="fn"><span class="fn"><span class="fn">Y</span>.hom</span>.unop</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.opToOverOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L942-L946">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opToOverOp"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opToOverOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span></span></div></div><p>The canonical functor by reversing structure arrows.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Under.opToOverOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.opToOverOp_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L943-L943">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opToOverOp_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opToOverOp_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z Y : <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opToOverOp">CategoryTheory.Under.opToOverOp</a> <span class="fn">X</span>)</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.unop</span>.right</span>.op</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.opToOverOp_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L943-L943">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opToOverOp_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opToOverOp_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opToOverOp">CategoryTheory.Under.opToOverOp</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">Y</span>)</span>.hom</span>.op</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.opEquivOpUnder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L948-L954">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opEquivOpUnder"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opEquivOpUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opToOpUnder">Over.opToOpUnder</a></code> is an equivalence of categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Over.opEquivOpUnder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.opEquivOpUnder_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L949-L949">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opEquivOpUnder_functor"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opEquivOpUnder_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opEquivOpUnder">CategoryTheory.Over.opEquivOpUnder</a> <span class="fn">X</span>)</span>.functor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opToOpUnder">CategoryTheory.Over.opToOpUnder</a> <span class="fn">X</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.opEquivOpUnder_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L949-L949">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opEquivOpUnder_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opEquivOpUnder_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opEquivOpUnder">CategoryTheory.Over.opEquivOpUnder</a> <span class="fn">X</span>)</span>.unitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.opEquivOpUnder_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L949-L949">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opEquivOpUnder_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opEquivOpUnder_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opEquivOpUnder">CategoryTheory.Over.opEquivOpUnder</a> <span class="fn">X</span>)</span>.counitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opToOverOp">CategoryTheory.Under.opToOverOp</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opToOpUnder">CategoryTheory.Over.opToOpUnder</a> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.opEquivOpUnder_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L949-L949">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opEquivOpUnder_inverse"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opEquivOpUnder_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opEquivOpUnder">CategoryTheory.Over.opEquivOpUnder</a> <span class="fn">X</span>)</span>.inverse</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opToOverOp">CategoryTheory.Under.opToOverOp</a> <span class="fn">X</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.opToOpOver"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L956-L960">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opToOpOver"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opToOpOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span></div></div><p>The canonical functor by reversing structure arrows.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Under.opToOpOver" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.opToOpOver_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L957-L957">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opToOpOver_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opToOpOver_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opToOpOver">CategoryTheory.Under.opToOpOver</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn"><span class="fn"><span class="fn">Y</span>.hom</span>.unop</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.opToOpOver_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L957-L957">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opToOpOver_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opToOpOver_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z Y : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opToOpOver">CategoryTheory.Under.opToOpOver</a> <span class="fn">X</span>)</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn"><span class="fn"><span class="fn">f</span>.right</span>.unop</span> <span class="fn">⋯</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.opToUnderOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L962-L966">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opToUnderOp"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opToUnderOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span></span></div></div><p>The canonical functor by reversing structure arrows.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Over.opToUnderOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.opToUnderOp_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L963-L963">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opToUnderOp_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opToUnderOp_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z Y : <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opToUnderOp">CategoryTheory.Over.opToUnderOp</a> <span class="fn">X</span>)</span>.map</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.homMk">CategoryTheory.Under.homMk</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.unop</span>.left</span>.op</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.opToUnderOp_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L963-L963">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opToUnderOp_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">opToUnderOp_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opToUnderOp">CategoryTheory.Over.opToUnderOp</a> <span class="fn">X</span>)</span>.obj</span> <span class="fn">Y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.mk">CategoryTheory.Under.mk</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">Y</span>)</span>.hom</span>.op</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.opEquivOpOver"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L968-L974">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opEquivOpOver"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opEquivOpOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span>)</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opToOpOver">Under.opToOpOver</a></code> is an equivalence of categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Under.opEquivOpOver" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.opEquivOpOver_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L969-L969">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opEquivOpOver_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opEquivOpOver_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opEquivOpOver">CategoryTheory.Under.opEquivOpOver</a> <span class="fn">X</span>)</span>.counitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opToUnderOp">CategoryTheory.Over.opToUnderOp</a> <span class="fn">X</span>)</span>.comp</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opToOpOver">CategoryTheory.Under.opToOpOver</a> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.opEquivOpOver_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L969-L969">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opEquivOpOver_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opEquivOpOver_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opEquivOpOver">CategoryTheory.Under.opEquivOpOver</a> <span class="fn">X</span>)</span>.unitIso</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.opEquivOpOver_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L969-L969">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opEquivOpOver_functor"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opEquivOpOver_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opEquivOpOver">CategoryTheory.Under.opEquivOpOver</a> <span class="fn">X</span>)</span>.functor</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opToOpOver">CategoryTheory.Under.opToOpOver</a> <span class="fn">X</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.opEquivOpOver_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/52e329815d8c2be3b3630cfef7ae62f68d836fc5/Mathlib/CategoryTheory/Comma/Over.lean#L969-L969">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opEquivOpOver_inverse"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">opEquivOpOver_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Under.opEquivOpOver">CategoryTheory.Under.opEquivOpOver</a> <span class="fn">X</span>)</span>.inverse</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Over.html#CategoryTheory.Over.opToUnderOp">CategoryTheory.Over.opToUnderOp</a> <span class="fn">X</span></span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>